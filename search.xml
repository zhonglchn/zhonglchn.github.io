<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>狂人日记</title>
      <link href="/2021/03/28/%E7%8B%82%E4%BA%BA%E6%97%A5%E8%AE%B0/"/>
      <url>/2021/03/28/%E7%8B%82%E4%BA%BA%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>作者：鲁迅</p><p><strong>狂人日记序</strong></p><p>某君昆仲，今隐其名，皆余昔日在中学时良友；分隔多年，消息渐阙。日前偶闻其一大病；适归故乡，迂道往访，则仅晤一人，言病者其弟也。劳君远道来视，然已早愈，赴某地候补矣。因大笑，出示日记二册，谓可见当日病状，不妨献诸旧友。持归阅一过，知所患盖“迫害狂”之类。语颇错杂无伦次，又多荒唐之言；亦不著月日，惟墨色字体不一，知非一时所书。间亦有略具联络者，今撮录一篇，以供医家研究。记中语误，一字不易；惟人名虽皆村人，不为世间所知，无关大体，然亦悉易去。至于书名，则本人愈后所题，不复改也。七年四月二日识。</p><p><strong>一</strong></p><p>今天晚上，很好的月光。</p><p>我不见他，已是三十多年；今天见了，精神分外爽快。才知道以前的三十多年，全是发昏；然而须十分小心。不然，那赵家的狗，何以看我两眼呢？</p><p>我怕得有理。</p><p><strong>二</strong></p><p>今天全没月光，我知道不妙。早上小心出门，赵贵翁的眼色便怪：似乎怕我，似乎想害我。还有七八个人，交头接耳的议论我，张着嘴，对我笑了一笑；我便从头直冷到脚根，晓得他们布置，都已妥当了。</p><p>我可不怕，仍旧走我的路。前面一伙小孩子，也在那里议论我；眼色也同赵贵翁一样，脸色也铁青。我想我同小孩子有什么仇，他也这样。忍不住大声说，“你告诉我！”他们可就跑了。</p><p>我想：我同赵贵翁有什么仇，同路上的人又有什么仇；只有廿年以前，把古久先生的陈年流水簿子，踹了一脚，古久先生很不高兴。赵贵翁虽然不认识他，一定也听到风声，代抱不平；约定路上的人，同我作冤对。但是小孩子呢？那时候，他们还没有出世，何以今天也睁着怪眼睛，似乎怕我，似乎想害我。这真教我怕，教我纳罕而且伤心。</p><p>我明白了。这是他们娘老子教的！</p><p><strong>三</strong></p><p>晚上总是睡不着。凡事须得研究，才会明白。</p><p>他们——也有给知县打枷过的，也有给绅士掌过嘴的，也有衙役占了他妻子的，也有老子娘被债主逼死的；他们那时候的脸色，全没有昨天这么怕，也没有这么凶。</p><p>最奇怪的是昨天街上的那个女人，打他儿子，嘴里说道，“老子呀！我要咬你几口才出气！”他眼睛却看着我。我出了一惊，遮掩不住；那青面獠牙的一伙人，便都哄笑起来。陈老五赶上前，硬把我拖回家中了。</p><p>拖我回家，家里的人都装作不认识我；他们的脸色，也全同别人一样。进了书房，便反扣上门，宛然是关了一只鸡鸭。这一件事，越教我猜不出底细。</p><p>前几天，狼子村的佃户来告荒，对我大哥说，他们村里的一个大恶人，给大家打死了；几个人便挖出他的心肝来，用油煎炒了吃，可以壮壮胆子。我插了一句嘴，佃户和大哥便都看我几眼。今天才晓得他们的眼光，全同外面的那伙人一模一样。</p><p>想起来，我从顶上直冷到脚跟。</p><p>他们会吃人，就未必不会吃我。</p><p>你看那女人“咬你几口”的话，和一伙青面獠牙人的笑，和前天佃户的话，明明是暗号。我看出他话中全是毒，笑中全是刀。他们的牙齿，全是白厉厉的排着，这就是吃人的家伙。</p><p>照我自己想，虽然不是恶人，自从踹了古家的簿子，可就难说了。他们似乎别有心思，我全猜不出。况且他们一翻脸，便说人是恶人。我还记得大哥教我做论，无论怎样好人，翻他几句，他便打上几个圈；原谅坏人几句，他便说“翻天妙手，与众不同”。我那里猜得到他们的心思，究竟怎样；况且是要吃的时候。</p><p>凡事总须研究，才会明白。古来时常吃人，我也还记得，可是不甚清楚。我翻开历史一查，这历史没有年代，歪歪斜斜的每叶上都写着“仁义道德”几个字。我横竖睡不着，仔细看了半夜，才从字缝里看出字来，满本都写着两个字是“吃人”！</p><p>书上写着这许多字，佃户说了这许多话，却都笑吟吟的睁着怪眼看我。</p><p>我也是人，他们想要吃我了！</p><p><strong>四</strong></p><p>早上，我静坐了一会儿。陈老五送进饭来，一碗菜，一碗蒸鱼；这鱼的眼睛，白而且硬，张着嘴，同那一伙想吃人的人一样。吃了几筷，滑溜溜的不知是鱼是人，便把他兜肚连肠的吐出。</p><p>我说“老五，对大哥说，我闷得慌，想到园里走走。”老五不答应，走了；停一会，可就来开了门。</p><p>我也不动，研究他们如何摆布我；知道他们一定不肯放松。果然！我大哥引了一个老头子，慢慢走来；他满眼凶光，怕我看出，只是低头向着地，从眼镜横边暗暗看我。大哥说，“今天你仿佛很好。”我说“是的。”大哥说，“今天请何先生来，给你诊一诊。”我说“可以！”其实我岂不知道这老头子是刽子手扮的！无非借了看脉这名目，揣一揣肥瘠：因这功劳，也分一片肉吃。我也不怕；虽然不吃人，胆子却比他们还壮。伸出两个拳头，看他如何下手。老头子坐着，闭了眼睛，摸了好一会，呆了好一会；便张开他鬼眼睛说，“不要乱想。静静的养几天，就好了。”</p><p>不要乱想，静静的养！养肥了，他们是自然可以多吃；我有什么好处，怎么会“好了”？他们这群人，又想吃人，又是鬼鬼祟祟，想法子遮掩，不敢直截下手，真要令我笑死。我忍不住，便放声大笑起来，十分快活。自己晓得这笑声里面，有的是义勇和正气。老头子和大哥，都失了色，被我这勇气正气镇压住了。</p><p>但是我有勇气，他们便越想吃我，沾光一点这勇气。老头子跨出门，走不多远，便低声对大哥说道，“赶紧吃罢！”大哥点点头。原来也有你！这一件大发见，虽似意外，也在意中：合伙吃我的人，便是我的哥哥！</p><p>吃人的是我哥哥！</p><p>我是吃人的人的兄弟！</p><p>我自己被人吃了，可仍然是吃人的人的兄弟！</p><p><strong>五</strong></p><p>这几天是退一步想：假使那老头子不是刽子手扮的，真是医生，也仍然是吃人的人。他们的祖师李时珍做的“本草什么”上，明明写着人肉可以煎吃；他还能说自己不吃人么？</p><p>至于我家大哥，也毫不冤枉他。他对我讲书的时候，亲口说过可以“易子而食”；又一回偶然议论起一个不好的人，他便说不但该杀，还当“食肉寝皮”。我那时年纪还小，心跳了好半天。前天狼子村佃户来说吃心肝的事，他也毫不奇怪，不住的点头。可见心思是同从前一样狠。既然可以“易子而食”，便什么都易得，什么人都吃得。我从前单听他讲道理，也糊涂过去；现在晓得他讲道理的时候，不但唇边还抹着人油，而且心里满装着吃人的意思。</p><p><strong>六</strong></p><p>黑漆漆的，不知是日是夜。赵家的狗又叫起来了。</p><p>狮子似的凶心，兔子的怯弱，狐狸的狡猾，……</p><p><strong>七</strong></p><p>我晓得他们的方法，直捷杀了，是不肯的，而且也不敢，怕有祸祟。所以他们大家连络，布满了罗网，逼我自戕。试看前几天街上男女的样子，和这几天我大哥的作为，便足可悟出八九分了。最好是解下腰带，挂在梁上，自己紧紧勒死；他们没有杀人的罪名，又偿了心愿，自然都欢天喜地的发出一种呜呜咽咽的笑声。否则惊吓忧愁死了，虽则略瘦，也还可以首肯几下。</p><p>他们是只会吃死肉的！——记得什么书上说，有一种东西，叫“海乙那”的，眼光和样子都很难看；时常吃死肉，连极大的骨头，都细细嚼烂，咽下肚子去，想起来也教人害怕。“海乙那”是狼的亲眷，狼是狗的本家。前天赵家的狗，看我几眼，可见他也同谋，早已接洽。老头子眼看着地，岂能瞒得我过。</p><p>最可怜的是我的大哥，他也是人，何以毫不害怕；而且合伙吃我呢？还是历来惯了，不以为非呢？还是丧了良心，明知故犯呢？</p><p>我诅咒吃人的人，先从他起头；要劝转吃人的人，也先从他下手。</p><p><strong>八</strong></p><p>其实这种道理，到了现在，他们也该早已懂得，……</p><p>忽然来了一个人；年纪不过二十左右，相貌是不很看得清楚，满面笑容，对了我点头，他的笑也不像真笑。我便问他，“吃人的事，对么？”他仍然笑着说，“不是荒年，怎么会吃人。”我立刻就晓得，他也是一伙，喜欢吃人的；便自勇气百倍，偏要问他。</p><p>“对么？”</p><p>“这等事问他什么。你真会……说笑话。……今天天气很好。”</p><p>天气是好，月色也很亮了。可是我要问你，“对么？”</p><p>他不以为然了。含含胡胡的答道，“不……”</p><p>“不对？他们何以竟吃？！”</p><p>“没有的事……”</p><p>“没有的事？狼子村现吃；还有书上都写着，通红斩新！”</p><p>他便变了脸，铁一般青。睁着眼说，“有许有的，这是从来如此……”</p><p>“从来如此，便对么？”</p><p>“我不同你讲这些道理；总之你不该说，你说便是你错！”</p><p>我直跳起来，张开眼，这人便不见了。全身出了一大片汗。他的年纪，比我大哥小得远，居然也是一伙；这一定是他娘老子先教的。还怕已经教给他儿子了；所以连小孩子，也都恶狠狠的看我。</p><p><strong>九</strong></p><p>自己想吃人，又怕被别人吃了，都用着疑心极深的眼光，面面相觑。……</p><p>去了这心思，放心做事走路吃饭睡觉，何等舒服。这只是一条门槛，一个关头。他们可是父子兄弟夫妇朋友师生仇敌和各不相识的人，都结成一伙，互相劝勉，互相牵掣，死也不肯跨过这一步。</p><p><strong>十</strong></p><p>大清早，去寻我大哥；他立在堂门外看天，我便走到他背后，拦住门，格外沉静，格外和气的对他说，</p><p>“大哥，我有话告诉你。”</p><p>“你说就是，”他赶紧回过脸来，点点头。</p><p>“我只有几句话，可是说不出来。大哥，大约当初野蛮的人，都吃过一点人。后来因为心思不同，有的不吃人了，一味要好，便变了人，变了真的人。有的却还吃，——也同虫子一样，有的变了鱼鸟猴子，一直变到人。有的不要好，至今还是虫子。这吃人的人比不吃人的人，何等惭愧。怕比虫子的惭愧猴子，还差得很远很远。</p><p>“易牙蒸了他儿子，给桀纣吃，还是一直从前的事。谁晓得从盘古开辟天地以后，一直吃到易牙的儿子；从易牙的儿子，一直吃到徐锡林；从徐锡林，又一直吃到狼子村捉住的人。去年城里杀了犯人，还有一个生痨病的人，用馒头蘸血舐。</p><p>“他们要吃我，你一个人，原也无法可想；然而又何必去入伙。吃人的人，什么事做不出；他们会吃我，也会吃你，一伙里面，也会自吃。但只要转一步，只要立刻改了，也就是人人太平。虽然从来如此，我们今天也可以格外要好，说是不能！大哥，我相信你能说，前天佃户要减租，你说过不能。”</p><p>当初，他还只是冷笑，随后眼光便凶狠起来，一到说破他们的隐情，那就满脸都变成青色了。大门外立着一伙人，赵贵翁和他的狗，也在里面，都探头探脑的挨进来。有的是看不出面貌，似乎用布蒙着；有的是仍旧青面獠牙，抿着嘴笑。我认识他们是一伙，都是吃人的人。可是也晓得他们心思很不一样，一种是以为从来如此，应该吃的；一种是知道不该吃，可是仍然要吃，又怕别人说破他，所以听了我的话，越发气愤不过，可是抿着嘴冷笑。</p><p>这时候，大哥也忽然显出凶相，高声喝道，“都出去！疯子有什么好看！”</p><p>这时候，我又懂得一件他们的巧妙了。他们岂但不肯改，而且早已布置；预备下一个疯子的名目罩上我。将来吃了，不但太平无事，怕还会有人见情。佃户说的大家吃了一个恶人，正是这方法。这是他们的老谱！</p><p>陈老五也气愤愤的直走进来。如何按得住我的口，我偏要对这伙人说，“你们可以改了，从真心改起！要晓得将来容不得吃人的人，活在世上。</p><p>“你们要不改，自己也会吃尽。即使生得多，也会给真的人除灭了，同猎人打完狼子一样！——同虫子一样！”</p><p>那一伙人，都被陈老五赶走了。大哥也不知那里去了。陈老五劝我回屋子里去。屋里面全是黑沉沉的。横梁和椽子都在头上发抖；抖了一会，就大起来，堆在我身上。</p><p>万分沉重，动弹不得；他的意思是要我死。我晓得他的沉重是假的，便挣扎出来，出了一身汗。可是偏要说，“你们立刻改了，从真心改起！你们要晓得将来是容不得吃人的人，……”</p><p><strong>十一</strong></p><p>太阳也不出，门也不开，日日是两顿饭。</p><p>我捏起筷子，便想起我大哥；晓得妹子死掉的缘故，也全在他。那时我妹子才五岁，可爱可怜的样子，还在眼前。母亲哭个不住，他却劝母亲不要哭；大约因为自己吃了，哭起来不免有点过意不去。如果还能过意不去，……妹子是被大哥吃了，母亲知道没有，我可不得而知。</p><p>母亲想也知道；不过哭的时候，却并没有说明，大约也以为应当的了。记得我四五岁时，坐在堂前乘凉，大哥说爷娘生病，做儿子的须割下一片肉来，煮熟了请他吃，才算好人；母亲也没有说不行。一片吃得，整个的自然也吃得。但是那天的哭法，现在想起来，实在还教人伤心，这真是奇极的事！</p><p><strong>十二</strong></p><p>不能想了。</p><p>四千年来时时吃人的地方，今天才明白，我也在其中混了多年；大哥正管着家务，妹子恰恰死了，他未必不和在饭菜里，暗暗给我们吃。</p><p>我未必无意之中，不吃了我妹子的几片肉，现在也轮到我自己，……有了四千年吃人履历的我，当初虽然不知道，现在明白，难见真的人！</p><p><strong>十三</strong></p><p>没有吃过人的孩子，或者还有？</p><p>救救孩子……</p><p>​                                                                                                                                                                一九一八年四月。</p>]]></content>
      
      
      <categories>
          
          <category> 文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 名人 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker</title>
      <link href="/2020/03/16/Docker/"/>
      <url>/2020/03/16/Docker/</url>
      
        <content type="html"><![CDATA[<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>目标1: 掌握Docker基础知识</p><p>目标2: 能够理解Docker镜像与容器的概念</p><p>目标3: 完成Docker安装与启动</p><p>目标4: 掌握Docker镜像与容器相关命令</p><p>目标5: 掌握Tomcat Nginx 等软件的常用应用的安装</p><p>目标6: 掌握docker迁移与备份相关命令</p><p>目标7: 能够运用Dockerfile编写创建镜像的脚本</p><p>目标8: 能够搭建与使用docker私有仓库</p><h2 id="01、虚拟化介绍"><a href="#01、虚拟化介绍" class="headerlink" title="01、虚拟化介绍"></a>01、虚拟化介绍</h2><blockquote><p>目标: 了解虚拟化及虚拟化种类。</p></blockquote><h4 id="1-1-什么是虚拟化"><a href="#1-1-什么是虚拟化" class="headerlink" title="1.1 什么是虚拟化"></a>1.1 什么是虚拟化</h4><ul><li>在计算机中，虚拟化（英语：Virtualization）是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及存储等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，使用户可以比原本的组态更好的方式来应用这些资源。这些资源的新虚拟部分是不受现有资源的架设方式，地域或物理组态所限制。一般所指的虚拟化资源包括计算能力和资料存储。</li><li>在实际的生产环境中，虚拟化技术主要用来解决高性能的物理硬件产能过剩和老的旧的硬件产能过低的重组重用，透明化底层物理硬件，<strong>从而最大化的利用物理硬件对资源充分利用</strong></li><li>虚拟化技术种类很多，例如：软件虚拟化、硬件虚拟化、内存虚拟化、网络虚拟化、桌面虚拟化、服务虚拟化、虚拟机等等。</li></ul><h4 id="1-2-虚拟化种类"><a href="#1-2-虚拟化种类" class="headerlink" title="1.2 虚拟化种类"></a>1.2 虚拟化种类</h4><ul><li><p>全虚拟化架构</p><p>虚拟机的监视器（hypervisor）是类似于用户的应用程序运行在主机的OS之上，如VMware的workstation，这种虚拟化产品提供了虚拟的硬件)。</p><p><img src="/2020/03/16/Docker/1574128224856.png" alt="1574128224856"> </p><blockquote><p>说明: 虚拟出来的操作系统可以与本机操作系统<strong>不一样</strong>(内核)。</p></blockquote></li><li><p>OS层虚拟化架构</p><p><img src="/2020/03/16/Docker/1574128530943.png" alt="1574128530943">  </p><blockquote><p>说明: 虚拟出来的操作系统与本机操作系统<strong>一样</strong>(内核)。</p></blockquote></li><li><p>硬件层虚拟化</p><p><img src="/2020/03/16/Docker/1574129008763.png" alt="1574129008763">  </p><p><strong>硬件层的虚拟化具有高性能和隔离性</strong>，因为hypervisor直接在硬件上运行，有利于控制VM的OS访问硬件资源，使用这种解决方案的产品有VMware ESXi 和 Xen server</p><p>Hypervisor是一种运行在物理服务器和操作系统之间的中间软件层,可允许多个操作系统和应用共享一套基础物理硬件，因此也可以看作是虚拟环境中的“元”操作系统，它可以协调访问服务器上的所有物理设备和虚拟机，也叫虚拟机监视器（Virtual Machine Monitor，VMM）。</p><p>Hypervisor是所有虚拟化技术的核心。当服务器启动并执行Hypervisor时，它会给每一台虚拟机分配适量的内存、CPU、网络和磁盘，并加载所有虚拟机的客户操作系统。</p><p>Hypervisor是所有虚拟化技术的核心，软硬件架构和管理更高效、更灵活，硬件的效能能够更好地发挥出来。常见的产品有：VMware、KVM、Xen等等。</p><blockquote><p>说明: 虚拟出来的操作系统与本机操作系统<strong>不一样</strong>(内核)。但<strong>没有宿主机</strong>操作系统。</p></blockquote></li></ul><p><strong>小结</strong></p><blockquote><p>虚拟化:（英语: Virtualization）是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及存储等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，使用户可以比原本的组态更好的方式来应用这些资源。</p><p>虚拟化技术: 软件虚拟化、硬件虚拟化、内存虚拟化、网络虚拟化(vip)、桌面虚拟化、服务虚拟化、虚拟机。</p></blockquote><h2 id="02、什么是docker"><a href="#02、什么是docker" class="headerlink" title="02、什么是docker"></a>02、什么是docker</h2><blockquote><p>目标: 了解什么是docker?</p></blockquote><h4 id="2-1-docker简介"><a href="#2-1-docker简介" class="headerlink" title="2.1 docker简介"></a>2.1 docker简介</h4><p><img src="/2020/03/16/Docker/1556243001933.png" alt="1556243001933"></p><ul><li><p>Docker 是一个开源的<strong>应用容器引擎</strong>，基于 Go 语言开发。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。 </p></li><li><p>Docker 应用场景</p><ul><li>Web 应用的自动化打包和发布 </li><li>自动化测试和持续集成、发布 </li><li>在服务型环境中部署和调整数据库或其他的后台应用</li></ul></li><li><p>使用Docker可以实现开发人员的开发环境、测试人员的测试环境、运维人员的生产环境的一致性。</p><p><img src="/2020/03/16/Docker/1574126073144.png" alt="1574126073144"> </p><blockquote><p>Docker借鉴了标准集装箱的概念。标准集装箱将货物运往世界各地，Docker将这个模型运用到自己的设计中，唯一不同的是：集装箱运输货物，而Docker运输软件。 </p></blockquote></li></ul><h4 id="2-2-docker特点"><a href="#2-2-docker特点" class="headerlink" title="2.2 docker特点"></a>2.2 docker特点</h4><ul><li><strong>上手快</strong><ul><li>用户只需要几分钟，就可以把自己的程序“Docker化”。Docker依赖于“写时复制”（copy-on-write）模型，使修改应用程序也非常迅速，可以说达到“随心所致，代码即改”的境界。</li><li>随后，就可以创建容器来运行应用程序了。大多数Docker容器只需要不到1秒中即可启动。由于去除了管理程序的开销，Docker容器拥有很高的性能，同时同一台宿主机中也可以运行更多的容器，使用户尽可能的充分利用系统资源。</li></ul></li><li><strong>职责明确</strong><ul><li>使用Docker，开发人员只需要关心容器中运行的应用程序，而运维人员只需要关心如何管理容器。Docker设计的目的就是要加强开发人员写代码的开发环境与应用程序要部署的生产环境一致性。从而降低那种“开发时一切正常，肯定是运维的问题（测试环境都是正常的，上线后出了问题就归结为肯定是运维的问题）。</li></ul></li><li><strong>快速高效的开发生命周期</strong><ul><li>Docker的目标之一就是缩短代码从开发、测试到部署、上线运行的周期，让你的应用程序具备可移植性，易于构建，并易于协作。（通俗一点说，Docker就像一个盒子，里面可以装很多物件，如果需要这些物件的可以直接将该大盒子拿走，而不需要从该盒子中一件件的取）。</li></ul></li><li><strong>鼓励使用面向服务的架构</strong><ul><li>Docker还鼓励面向服务的体系结构和微服务架构。Docker推荐单个容器只运行一个应用程序或进程，这样就形成了一个分布式的应用程序模型，在这种模型下，应用程序或者服务都可以表示为一系列内部互联的容器，从而使分布式部署应用程序，扩展或调试应用程序都变得非常简单，同时也提高了程序的内省性。（当然，可以在一个容器中运行多个应用程序）。</li></ul></li></ul><p><strong>小结</strong></p><blockquote><p>Docker是一个开源应用容器引擎,使用go语言开发，适用于企业<strong>应用部署解决方案</strong>。</p></blockquote><h2 id="03、容器-amp-虚拟机对比"><a href="#03、容器-amp-虚拟机对比" class="headerlink" title="03、容器&amp;虚拟机对比"></a>03、容器&amp;虚拟机对比</h2><blockquote><p>目标: 说出Docker容器与虚拟机相比的优势。</p></blockquote><h4 id="3-1-本质上的区别"><a href="#3-1-本质上的区别" class="headerlink" title="3.1 本质上的区别"></a>3.1 本质上的区别</h4><p><img src="/2020/03/16/Docker/1574129620520.png" alt="1574129620520">  </p><ul><li><strong>VMs虚拟服务:</strong><ul><li>Server基础设施服务，它可以是你的个人电脑，数据中心的服务器或者云主机。</li><li>Host OS当前的操作系统，比如windows和linux系统等。</li><li>hypervisor: 虚拟机监视器是一种虚拟化技术。可以在主操作系统之上运行多个不同的操作系统。比如vmware和virturebox等。</li><li>Guest OS就是虚拟子系统也就是我们的centos。</li><li>Bins、Libs安装应用需要依赖的组件和环境。比如gcc,gcc++或者yum等。</li><li>App 安装我们对应的应用，比如: mysql、tomcat、jdk等。应用安装之后，就可以在各个操作系统分别运行应用了，这样各个应用就是相互隔离的。</li></ul></li><li><strong>Docker容器：</strong><ul><li>Server基础设施服务，它可以是你的个人电脑，数据中心的服务器或者云主机。</li><li>Host OS当前的操作系统，比如windows和linux系统等。</li><li>Docker Engine: 负责和底层的系统进行交互和共享底层系统的资源。取代了Hypevisor.它是运行在操作系统之上的后台进程，负责管理Docker容器。</li><li>各种依赖，对于Docker，应用的所有依赖都打包在Docker镜像中，Docker容器是基于Docker镜像创建的。</li><li>App应用，应用的源代码与他的依赖都打包在Docker镜像中，不同的应用需要不同的Docker镜像，不同的应用运行在不同的Docker容器中，它们是相互隔离的。</li></ul></li></ul><h4 id="3-2-使用上的区别"><a href="#3-2-使用上的区别" class="headerlink" title="3.2 使用上的区别"></a>3.2 使用上的区别</h4><p><img src="/2020/03/16/Docker/1574072004851.png" alt="1574072004851"> </p><table><thead><tr><th></th><th><strong>虚拟机</strong></th><th><strong>容器</strong></th></tr></thead><tbody><tr><td><strong>占用磁盘空间</strong></td><td>非常大，GB级</td><td>小，MB甚至KB级</td></tr><tr><td><strong>启动速度</strong></td><td>慢，分钟级</td><td>快，秒级</td></tr><tr><td><strong>运行形态</strong></td><td>运行于Hypervisor上</td><td>直接运行在宿主机内核上</td></tr><tr><td><strong>并发性</strong></td><td>一台宿主机上十几个，最多几十个</td><td>上百个，甚至数百上千个</td></tr><tr><td><strong>性能</strong></td><td>逊于宿主机</td><td>接近宿主机本地进程</td></tr><tr><td><strong>资源利用率</strong></td><td>低</td><td>高</td></tr><tr><td><strong>小结</strong></td><td></td><td></td></tr></tbody></table><blockquote><p>Docker容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统虚拟机则是在硬件层面实现虚拟化。与传统的虚拟机相比，Docker优势体现为启动速度快、占用体积小。 </p></blockquote><h2 id="04、Docker：组成结构"><a href="#04、Docker：组成结构" class="headerlink" title="04、Docker：组成结构"></a>04、Docker：组成结构</h2><blockquote><p>目标: 了解Docker的组成结构</p></blockquote><p><img src="/2020/03/16/Docker/1574129782413.png" alt="1574129782413"> </p><table><thead><tr><th align="center">名称</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">Docker 镜像 (Images)</td><td align="left">Docker 镜像是用于创建 Docker 容器的模板。镜像是基于联合文件系统的一种层式结构， 由一系列指令一步一步构建出来(只读不能修改)。</td></tr><tr><td align="center">Docker 容器 (Container)</td><td align="left">容器是独立运行的一个或一组应用。镜像相当于类，容器相当于类的实例</td></tr><tr><td align="center">Docker 客户端(Client)</td><td align="left">Docker 客户端通过命令行或者其他工具使用 Docker API 与 Docker 的守护进程通信。</td></tr><tr><td align="center">Docker 主机(Host)</td><td align="left">一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。</td></tr><tr><td align="center">Docker守护进程</td><td align="left">是Docker服务器端进程，负责支撑Docker 容器的运行以及镜像的管理。</td></tr><tr><td align="center">Docker 仓库 DockerHub(Registry)</td><td align="left">Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。 Docker Hub提供了庞大 的镜像集合供使用。用户也可以将自己本地的镜像推送到Docker仓库供其他人下载。</td></tr></tbody></table><p><strong>小结</strong></p><blockquote><p>Docker组成部分: 镜像、容器、客户端、主机、守护进程、仓库。</p></blockquote><h2 id="05、Docker：仓库介绍"><a href="#05、Docker：仓库介绍" class="headerlink" title="05、Docker：仓库介绍"></a>05、Docker：仓库介绍</h2><blockquote><p>目标: 了解什么是仓库？</p></blockquote><ul><li><p>Docker用Registry来保存用户构建的镜像。Registry分为<strong>公共</strong>和<strong>私有</strong>两种。Docker公司运营公共的Registry叫做Docker Hub。用户可以在Docker Hub注册账号，分享并保存自己的镜像（说明：在Docker Hub下载镜像巨慢，可以自己构建私有的Registry）。</p></li><li><p>官方仓库: <a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></p><p><img src="/2020/03/16/Docker/1572835410624.png" alt="1572835410624"> </p></li></ul><h2 id="06、Docker：安装"><a href="#06、Docker：安装" class="headerlink" title="06、Docker：安装"></a>06、Docker：安装</h2><blockquote><p>目标: 掌握Docker的安装</p></blockquote><ul><li><p>Docker可以运行在MAC、Windows、CentOS、DEBIAN、UBUNTU等操作系统上，提供社区版和企业版，本课程基于CentOS安装Docker。 </p><blockquote><p>注意：这里<strong>建议安装在CentOS7.x以上的版本</strong>，在CentOS6.x的版本中，安装前需要安装其他很多的环境而且Docker很多补丁不支持更新。root 123456</p></blockquote></li><li><p><code>资料</code>已经准备了安装好的镜像，直接挂载即可，挂载后，使用ifconfig命令查看本地ip:</p><p><img src="/2020/03/16/Docker/1574132472149.png" alt="1574132472149"> </p></li><li><p>以下是在CentOS7中安装Docker的步骤:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. yum 包更新到最新</span></span><br><span class="line">yum update</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2. 安装需要的软件包，yum-util提供yum-config-manager功能，另外两个是devicemapper驱动依赖</span></span><br><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 设置yum源为阿里云</span></span><br><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 安装docker【docker-ce: 社区版，免费；docker-ee：企业版，收费】</span></span><br><span class="line">yum install docker-ce -y</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5. 安装后查看docker版本</span></span><br><span class="line">docker -v</span><br></pre></td></tr></table></figure><p><img src="/2020/03/16/Docker/1574133798713.png" alt="1574133798713"> </p></li></ul><h2 id="07、Docker：设置ustc镜像源"><a href="#07、Docker：设置ustc镜像源" class="headerlink" title="07、Docker：设置ustc镜像源"></a>07、Docker：设置ustc镜像源</h2><blockquote><p>目标: 掌握镜像源的设置</p></blockquote><p>ustc是老牌的linux镜像服务提供者了，还在遥远的ubuntu 5.0.4版本的时候就在用。ustc的docker镜像加速器速度很快。ustc docker mirror的优势之一就是不需要注册，是真正的公共服务。 </p><p>访问地址: <a href="https://lug.ustc.edu.cn/wiki/mirrors/help/docker" target="_blank" rel="noopener">https://lug.ustc.edu.cn/wiki/mirrors/help/docker</a></p><p><img src="/2020/03/16/Docker/1574134043126.png" alt="1574134043126"> </p><p><strong>操作步骤</strong></p><ul><li><p>编辑文件/etc/docker/daemon.json</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 执行如下命令</span></span><br><span class="line">mkdir /etc/docker</span><br><span class="line">vi /etc/docker/daemon.json</span><br></pre></td></tr></table></figure></li><li><p>在文件中加入下面内容:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">"registry-mirrors": ["https://docker.mirrors.ustc.edu.cn"]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="08、Docker：服务相关命令"><a href="#08、Docker：服务相关命令" class="headerlink" title="08、Docker：服务相关命令"></a>08、Docker：服务相关命令</h2><blockquote><p>目标: 掌握docker服务相关命令</p></blockquote><p>常用命令:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动docker服务</span></span><br><span class="line"><span class="attr">systemctl</span> <span class="string">start docker</span></span><br><span class="line"><span class="comment"># 停止docker服务</span></span><br><span class="line"><span class="attr">systemctl</span> <span class="string">stop docker</span></span><br><span class="line"><span class="comment"># 重启docker服务</span></span><br><span class="line"><span class="attr">systemctl</span> <span class="string">restart docker</span></span><br><span class="line"><span class="comment"># 查看docker服务状态</span></span><br><span class="line"><span class="attr">systemctl</span> <span class="string">status docker</span></span><br><span class="line"><span class="comment"># 设置开机启动docker服务</span></span><br><span class="line"><span class="attr">systemctl</span> <span class="string">enable docker</span></span><br><span class="line"><span class="comment"># 查看docker概要信息</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">info</span></span><br><span class="line"><span class="comment"># 查看docker帮助文档</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">--help</span></span><br></pre></td></tr></table></figure><p>注意: systemctl命令是系统服务管理器指令。</p><p><img src="/2020/03/16/Docker/1574134702001.png" alt="1574134702001"> </p><p><strong>小结</strong></p><ul><li>启动docker服务: systemctl start docker</li><li>停止docker服务: systemctl stop docker</li></ul><h2 id="09、Docker：镜像相关命令"><a href="#09、Docker：镜像相关命令" class="headerlink" title="09、Docker：镜像相关命令"></a>09、Docker：镜像相关命令</h2><blockquote><p>目标: 掌握操作镜像的常用命令</p></blockquote><h4 id="9-1-镜像介绍"><a href="#9-1-镜像介绍" class="headerlink" title="9.1 镜像介绍"></a>9.1 镜像介绍</h4><ul><li><p>Docker镜像是由文件系统叠加而成（是一种文件的存储形式）；是docker中的核心概念，可以认为镜像就是对某些运行环境或者软件打的包，用户可以从docker仓库中下载基础镜像到本地，比如开发人员可以从docker仓库拉取（下载）一个只包含centos7系统的基础镜像，然后在这个镜像中安装jdk、mysql、Tomcat和自己开发的应用，最后将这些环境打成一个新的镜像。开发人员将这个新的镜像提交给测试人员进行测试，测试人员只需要在测试环境下运行这个镜像就可以了，这样就可以保证开发人员的环境和测试人员的环境完全一致。</p><p><img src="/2020/03/16/Docker/1574135167278.png" alt="1574135167278">  </p></li></ul><h4 id="9-2-查看镜像"><a href="#9-2-查看镜像" class="headerlink" title="9.2 查看镜像"></a>9.2 查看镜像</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看镜像可以使用如下命令:</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">images</span></span><br></pre></td></tr></table></figure><p><img src="/2020/03/16/Docker/1574136867098.png" alt="1574136867098"> </p><ul><li>REPOSITORY: 镜像名称</li><li>TAG: 镜像标签 (默认是可以省略的,也就是latest)</li><li>IMAGE ID: 镜像ID</li><li>CREATED: 镜像的创建日期（不是获取该镜像的日期）</li><li>SIZE: 镜像大小</li></ul><blockquote><p>说明: 这些镜像都是存储在docker宿主机的/var/lib/docker目录下。</p></blockquote><h4 id="9-3-搜索镜像"><a href="#9-3-搜索镜像" class="headerlink" title="9.3 搜索镜像"></a>9.3 搜索镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 如果你需要从网络中查找需要的镜像，可以通过以下命令搜索</span></span><br><span class="line">docker search 镜像名称</span><br></pre></td></tr></table></figure><p><img src="/2020/03/16/Docker/1574137244207.png" alt="1574137244207"> </p><ul><li>NAME: 镜像名称</li><li>DESCRIPTION: 镜像描述</li><li>STARS: 用户评价，反应一个镜像的受欢迎程度</li><li>OFFICIAL: 是否官方</li><li>AUTOMATED: 自动构建，表示该镜像由Docker Hub自动构建流程创建的</li></ul><p>推荐大家去官方搜索(<a href="http://hub.docker.com" target="_blank" rel="noopener">http://hub.docker.com</a>):</p><p><img src="/2020/03/16/Docker/1572838326986.png" alt="1572838326986"> </p><h4 id="9-4-拉取镜像"><a href="#9-4-拉取镜像" class="headerlink" title="9.4 拉取镜像"></a>9.4 拉取镜像</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拉取镜像就是从Docker仓库下载镜像到本地，镜像名称格式为 名称:版本号，如果版本号不指定则是最新的版本 命令如下:</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">pull 镜像名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取centos 7</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">pull centos:7</span></span><br><span class="line"><span class="comment"># 拉取centos 最后版本镜像</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">pull centos:latest</span></span><br></pre></td></tr></table></figure><p><img src="/2020/03/16/Docker/1574138674249.png" alt="1574138674249"> </p><h4 id="9-5-删除镜像"><a href="#9-5-删除镜像" class="headerlink" title="9.5 删除镜像"></a>9.5 删除镜像</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按照镜像id删除镜像</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">rmi 镜像ID</span></span><br><span class="line"><span class="comment"># 删除所有镜像(谨慎操作)</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">rmi `docker images -q`</span></span><br></pre></td></tr></table></figure><p><img src="/2020/03/16/Docker/1574138776049.png" alt="1574138776049"> </p><p><img src="/2020/03/16/Docker/1574138925582.png" alt="1574138925582"> </p><h2 id="10、Docker：容器相关命令"><a href="#10、Docker：容器相关命令" class="headerlink" title="10、Docker：容器相关命令"></a>10、Docker：容器相关命令</h2><blockquote><p>目标: 掌握操作容器相关的命令</p></blockquote><h4 id="10-1-查看容器"><a href="#10-1-查看容器" class="headerlink" title="10.1 查看容器"></a>10.1 查看容器</h4><ul><li><p>查看正在运行容器: docker ps</p></li><li><p>查看所有容器: docker ps -a </p></li><li><p>查看最后一次运行的容器: docker ps –l</p><p><img src="/2020/03/16/Docker/1574146204730.png" alt="1574146204730"> </p></li></ul><h4 id="10-2-创建与运行容器"><a href="#10-2-创建与运行容器" class="headerlink" title="10.2 创建与运行容器"></a>10.2 创建与运行容器</h4><p>可以基于已有的镜像来创建容器，创建与运行容器使用命令: docker run</p><p><strong>参数说明:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-i: 表示运行容器</span><br><span class="line"></span><br><span class="line">-t: 表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端。</span><br><span class="line"></span><br><span class="line">--name: 为创建的容器命名。</span><br><span class="line"></span><br><span class="line">-v: 表示目录映射关系（前者是宿主机目录，后者是容器的目录），可以使用多个－v做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到容器上。</span><br><span class="line"></span><br><span class="line">-d: 在run后面加上-d参数,则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加-i -t两个参数，创建后就会自动进去容器）。</span><br><span class="line"></span><br><span class="line">-p: 表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p做多个端口映射。</span><br></pre></td></tr></table></figure><h5 id="10-2-1-交互式容器"><a href="#10-2-1-交互式容器" class="headerlink" title="10.2.1 交互式容器"></a>10.2.1 交互式容器</h5><ul><li><p>以<strong>交互式</strong>方式创建并运行容器，启动完成后，直接进入当前容器。使用exit命令退出容器。需要注意的是以此种方式启动容器，如果退出容器，则容器会进入<strong>停止</strong>状态。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 先拉取一个镜像；这一步不是每次启动容器都要做的，而是因为前面我们删除了镜像，</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 无镜像可用所以才再拉取一个</span></span><br><span class="line">docker pull centos:7</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建并启动名称为 mycentos7 的交互式容器</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 容器名称 mycentos7</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 镜像名称:TAG (centos:7)  也可以使用镜像id (5e35e350aded)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> /bin/bash: 进入容器命令行</span></span><br><span class="line">docker run -it --name=mycentos7 centos:7 /bin/bash</span><br></pre></td></tr></table></figure><p><img src="/2020/03/16/Docker/1574149291840.png" alt="1574149291840">  </p></li></ul><h5 id="10-2-2-守互式容器"><a href="#10-2-2-守互式容器" class="headerlink" title="10.2.2 守互式容器"></a>10.2.2 守互式容器</h5><ul><li><p>创建一个守护式容器；如果对于一个需要长期运行的容器来说，我们可以创建一个守护式容器。命令如下（容器名称不能重复）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建并启动守护式容器</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 容器名称: mycentos2</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 镜像名称:TAG (centos:7)  也可以使用镜像id (5e35e350aded)</span></span><br><span class="line">docker run -di --name=mycentos2 centos:7</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入容器：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker <span class="built_in">exec</span> -it container_name (或者 container_id) /bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">exit</span>退出时，容器不会停止</span></span><br><span class="line">docker exec -it mycentos2 /bin/bash</span><br></pre></td></tr></table></figure><p><img src="/2020/03/16/Docker/1574150692267.png" alt="1574150692267"> </p><blockquote><p>说明: 守护式容器是一直运行的，退出只是退出终端，它还是在后台运行。</p></blockquote></li></ul><h4 id="10-3-停止或启动容器"><a href="#10-3-停止或启动容器" class="headerlink" title="10.3 停止或启动容器"></a>10.3 停止或启动容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 停止正在运行的容器: docker stop 容器名称|容器ID</span></span><br><span class="line">docker stop mycentos2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动已运行过的容器: docker start 容器名称|容器ID</span></span><br><span class="line">docker start mycentos2</span><br></pre></td></tr></table></figure><p><img src="/2020/03/16/Docker/1574151218515.png" alt="1574151218515"> </p><h4 id="10-4-重启容器"><a href="#10-4-重启容器" class="headerlink" title="10.4 重启容器"></a>10.4 重启容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 重启正在运行的容器: docker restart 容器名称|容器ID</span></span><br><span class="line">docker restart mycentos2</span><br></pre></td></tr></table></figure><p><img src="/2020/03/16/Docker/1574151366035.png" alt="1574151366035"> </p><h4 id="10-5-查看容器IP"><a href="#10-5-查看容器IP" class="headerlink" title="10.5 查看容器IP"></a>10.5 查看容器IP</h4><p>我们可以通过以下命令查看容器运行的各种数据:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在linux宿主机下查看 mycentos2 的ip</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker inspect 容器名称（容器ID）</span></span><br><span class="line"></span><br><span class="line">docker inspect mycentos2</span><br></pre></td></tr></table></figure><p><img src="/2020/03/16/Docker/1574152554022.png" alt="1574152554022"> </p><blockquote><p>容器之间在一个局域网内，linux宿主机器可以与容器进行通信；但是外部的物理机笔记本是不能与容器直接通信的，如果需要则需要通过宿主机器端口的代理。 </p></blockquote><h4 id="10-6-删除容器"><a href="#10-6-删除容器" class="headerlink" title="10.6 删除容器"></a>10.6 删除容器</h4><ul><li>删除指定的容器: docker rm 容器名称|容器ID</li><li>删除所有容器: docker rm `docker ps -a -q`</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker rm mycentos2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line">docker rm 2095a22bee70</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除所有容器</span></span><br><span class="line">docker rm `docker ps -a -q`</span><br></pre></td></tr></table></figure><p><img src="/2020/03/16/Docker/1574153377358.png" alt="1574153377358"> </p><p><img src="/2020/03/16/Docker/1574153254626.png" alt="1574153254626"> </p><blockquote><p>说明: 如果容器是运行状态则删除失败，需要停止容器才能删除 </p></blockquote><p><strong>注意: 只能删除停止的容器</strong></p><h2 id="11、Docker：容器文件拷贝"><a href="#11、Docker：容器文件拷贝" class="headerlink" title="11、Docker：容器文件拷贝"></a>11、Docker：容器文件拷贝</h2><blockquote><p>目标: 掌握文件拷贝命令</p></blockquote><ul><li><p>将linux宿主机中的文件拷贝到容器内可以使用命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker cp 需要拷贝的文件或目录 容器名称:容器目录</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建一个文件abc.txt </span></span><br><span class="line">touch abc.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 复制 abc.txt 到 mycentos2 的容器的 / 目录下 </span></span><br><span class="line">docker cp abc.txt mycentos2:/ </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入mycentos2容器 </span></span><br><span class="line">docker exec -it mycentos2 /bin/bash </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看容器 / 目录下文件</span></span><br><span class="line">ll</span><br></pre></td></tr></table></figure><p><img src="/2020/03/16/Docker/1574154371433.png" alt="1574154371433"> </p></li><li><p>将文件从容器内拷贝出来到linux宿主机使用命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker cp 容器名称:容器目录 需要拷贝的文件或目录</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入容器后创建文件aaa.txt</span></span><br><span class="line">touch aaa.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 退出容器</span></span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在Linux宿主机器执行复制；将容器mycentos2的/aaa.txt文件复制到 宿主机器的/root目录下</span></span><br><span class="line">docker cp mycentos2:/aaa.txt /root</span><br></pre></td></tr></table></figure><p><img src="/2020/03/16/Docker/1574154905200.png" alt="1574154905200"> </p><blockquote><p>注意: 停止状态的容器也是可以进行文件拷贝的，可以拷进去，也可以拷出来。</p></blockquote></li></ul><h2 id="12、Docker：容器目录挂载"><a href="#12、Docker：容器目录挂载" class="headerlink" title="12、Docker：容器目录挂载"></a>12、Docker：容器目录挂载</h2><blockquote><p>目标: 掌握目录挂载命令(其实就是目录映射)</p></blockquote><ul><li><p>可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而去影响容器。 </p></li><li><p>创建容器时添加-v参数，后边为宿主机目录:容器目录，例如： docker run -di -v /usr/local/test:/usr/local/test –name=mycentos3 centos:7</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建linux宿主机器要挂载的目录 </span></span><br><span class="line">mkdir /usr/local/test </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建并启动容器mycentos3</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 并挂载 linux中的/usr/<span class="built_in">local</span>/<span class="built_in">test</span>目录到容器的/usr/<span class="built_in">local</span>/<span class="built_in">test</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 也就是在 linux中的/usr/<span class="built_in">local</span>/<span class="built_in">test</span>中操作相当于对容器相应目录操作 </span></span><br><span class="line">docker run -di -v /usr/local/test:/usr/local/test --name=mycentos3 centos:7</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在linux下创建文件 </span></span><br><span class="line">touch /usr/local/test/bbb.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入容器 </span></span><br><span class="line">docker exec -it mycentos3 /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在容器中查看目录中是否有对应文件bbb.txt</span></span><br><span class="line">cd /usr/local/test</span><br><span class="line">ll</span><br></pre></td></tr></table></figure><p><img src="/2020/03/16/Docker/1574156479325.png" alt="1574156479325"> </p><blockquote><p>注意: 如果你共享的是多级的目录，可能会出现权限不足的提示。 这是因为CentOS7中的安全模块selinux把权限禁掉了，需要添加参数 –privileged=true 来解决挂载的目录没有权限的问题。 </p></blockquote></li></ul><h2 id="13、Docker：安装mysql容器"><a href="#13、Docker：安装mysql容器" class="headerlink" title="13、Docker：安装mysql容器"></a>13、Docker：安装mysql容器</h2><blockquote><p>目标: 掌握在docker中安装mysql容器</p></blockquote><p><strong>操作步骤</strong></p><ul><li><p>拉取镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 拉取MySQL 5.7镜像</span></span><br><span class="line">docker pull centos/mysql-57-centos7</span><br></pre></td></tr></table></figure><p><img src="/2020/03/16/Docker/1574157836005.png" alt="1574157836005"> </p></li><li><p>创建容器</p><p>docker run -di –name=mysql5.7 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root mysql</p><ul><li>-p 代表端口映射，格式为 宿主机映射端口:容器运行端口</li><li>-e 代表添加环境变量 MYSQL_ROOT_PASSWORD 是root用户的远程登陆密码（如果是在容器中使用root登录的话,那么其<strong>密码为空</strong>）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建mysql5.7容器 </span></span><br><span class="line">docker run -di --name=mysql5.7 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root centos/mysql-57-centos7</span><br></pre></td></tr></table></figure><p><img src="/2020/03/16/Docker/1574158421287.png" alt="1574158421287">  </p></li><li><p>操作容器mysql</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入mysql5.7容器</span></span><br><span class="line">docker exec -it mysql5.7 /bin/bash </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 登录容器里面的mysql </span></span><br><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p><img src="/2020/03/16/Docker/1574160456871.png" alt="1574160456871"> </p></li><li><p>远程登录mysql</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看ip；如果以后要内部连接该mysql，如其他容器中要连接mysql容器的mysql的时候，可以使用如下命令查看IP</span></span><br><span class="line">docker inspect mysql5.7</span><br></pre></td></tr></table></figure><p><img src="/2020/03/16/Docker/1574160657423.png" alt="1574160657423"> </p><p>使用SQLyou在windows中进行远程登录在docker容器中的mysql。  </p><p><img src="/2020/03/16/Docker/1574160942998.png" alt="1574160942998"> </p></li></ul><h2 id="14、Docker：安装tomcat容器"><a href="#14、Docker：安装tomcat容器" class="headerlink" title="14、Docker：安装tomcat容器"></a>14、Docker：安装tomcat容器</h2><blockquote><p>目标: 掌握在docker中安装tomcat容器</p></blockquote><p><strong>操作步骤</strong></p><ul><li><p>拉取镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 拉取tomcat镜像</span></span><br><span class="line">docker pull tomcat</span><br></pre></td></tr></table></figure><p><img src="/2020/03/16/Docker/1574215667463.png" alt="1574215667463"> </p></li><li><p>创建容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建tomcat容器;并挂载了webapps目录</span></span><br><span class="line">docker run -di --name=mytomcat -p 9000:8080 -v /usr/local/tomcat/webapps:/usr/local/tomcat/webapps tomcat</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看日志</span></span><br><span class="line">docker logs -f mytomcat</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果出现 WARNING: IPv4 forwarding is disabled. Networking will not work. </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行如下操作 </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1、编辑 sysctl.conf </span></span><br><span class="line">vi /etc/sysctl.conf </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、在上述打开的文件中后面添加 </span></span><br><span class="line">net.ipv4.ip_forward=1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3、重启network</span></span><br><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure><p><img src="/2020/03/16/Docker/1574216589588.png" alt="1574216589588"> </p><p>测试访问宿主机的端口号为9000的 tomcat。地址：http://宿主机ip:9000，也可以往/user/local/tomcat/webapps下部署应用，然后再访问。</p></li><li><p>部署web应用</p><ul><li><p>创建springboot_db数据库,再创建tb_user表</p><p><img src="/2020/03/16/Docker/1574218496038.png" alt="1574218496038"> </p></li><li><p>查看mysql5.7容器的ip地址(docker inspect mysql5.7)</p><p><img src="/2020/03/16/Docker/1574218688435.png" alt="1574218688435"> </p></li><li><p>修改springboot-high工程的application.yml</p><p><img src="/2020/03/16/Docker/1574218750102.png" alt="1574218750102"> </p></li><li><p>项目打成war包</p><p><img src="/2020/03/16/Docker/1574218794796.png" alt="1574218794796"> </p><p> 执行: mvn package -Dmaven.test.skip=true</p></li><li><p>上传ROOT.war到/usr/local/tomcat/webapps/目录下。</p><p><img src="/2020/03/16/Docker/1574218936784.png" alt="1574218936784"> </p></li><li><p>浏览器访问 (<a href="http://192.168.12.132:9000/user.html" target="_blank" rel="noopener">http://192.168.12.132:9000/user.html</a>)</p><p><img src="/2020/03/16/Docker/1574218968488.png" alt="1574218968488"> </p></li></ul></li></ul><h2 id="15、Docker：安装Nginx容器"><a href="#15、Docker：安装Nginx容器" class="headerlink" title="15、Docker：安装Nginx容器"></a>15、Docker：安装Nginx容器</h2><blockquote><p>目标: 掌握在docker中安装nginx容器</p></blockquote><p><strong>操作步骤</strong></p><ul><li><p>拉取镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 拉取nginx镜像 </span></span><br><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure></li><li><p>创建容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建nginx容器 </span></span><br><span class="line">docker run -di --name=mynginx -p 80:80 nginx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看日志</span></span><br><span class="line">docker logs -f mynginx</span><br></pre></td></tr></table></figure><p><img src="/2020/03/16/Docker/1574220424119.png" alt="1574220424119"> </p></li><li><p>测试访问(启动后再宿主机上访问: http://宿主机IP/)</p><p><img src="/2020/03/16/Docker/1574220471997.png" alt="1574220471997"> </p></li><li><p>配置反向代理(去掉9000端口)</p><p>官方的nginx镜像，nginx配置文件 nginx.conf 在/etc/nginx/目录下。</p><p>在容器内编辑配置文件不方便，我们可以先将配置文件从容器内拷贝到宿主机，编辑修改后再拷贝回去。</p><ul><li><p>第一步: 从mynginx容器拷贝配置文件到宿主机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp mynginx:/etc/nginx/nginx.conf nginx.conf</span><br></pre></td></tr></table></figure><p><img src="/2020/03/16/Docker/1574222059993.png" alt="1574222059993"> </p></li><li><p>第二步: 查看mytomcat容器的ip地址(docker inspect mytomcat)</p><p><img src="/2020/03/16/Docker/1574222289095.png" alt="1574222289095"> </p></li><li><p>第三步: 配置nginx.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen 80;</span><br><span class="line">server_name 127.0.0.1;</span><br><span class="line"></span><br><span class="line">location &#x2F; &#123;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;172.17.0.2:8080;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/03/16/Docker/1574222458673.png" alt="1574222458673"> </p></li><li><p>将修改后的配置文件拷贝到容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp nginx.conf mynginx:/etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure><p><img src="/2020/03/16/Docker/1574222603952.png" alt="1574222603952"> </p></li><li><p>重新启动容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart mynginx</span><br></pre></td></tr></table></figure><p><img src="/2020/03/16/Docker/1574223715466.png" alt="1574223715466"> </p></li></ul></li></ul><h2 id="16、Docker：安装Redis容器"><a href="#16、Docker：安装Redis容器" class="headerlink" title="16、Docker：安装Redis容器"></a>16、Docker：安装Redis容器</h2><blockquote><p>目标: 掌握在docker中安装redis容器</p></blockquote><p><strong>操作步骤</strong></p><ul><li><p>拉取镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 拉取redis镜像</span></span><br><span class="line">docker pull redis</span><br></pre></td></tr></table></figure></li><li><p>创建容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建redis容器</span></span><br><span class="line">docker run -di --name=myredis -p 6379:6379 redis</span><br><span class="line"></span><br><span class="line"><span class="meta"> #</span><span class="bash"> 查看redis日志</span></span><br><span class="line">docker logs -f myredis</span><br></pre></td></tr></table></figure><p><img src="/2020/03/16/Docker/1574224235332.png" alt="1574224235332"> </p></li><li><p>操作redis容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入redis容器</span></span><br><span class="line">docker exec -it myredis /bin/bash </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入redis安装目录 </span></span><br><span class="line">cd /usr/local/bin</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 连接redis </span></span><br><span class="line">./redis-cli</span><br></pre></td></tr></table></figure><p> <img src="/2020/03/16/Docker/1574224343951.png" alt="1574224343951"> </p></li><li><p>远程连接redis</p><p>可以使用redis图形界面客户端工具连接redis，端口也是6379。</p><p><img src="/2020/03/16/Docker/1574224541883.png" alt="1574224541883"> </p></li></ul><h2 id="17、Docker：安装Rabbitmq容器"><a href="#17、Docker：安装Rabbitmq容器" class="headerlink" title="17、Docker：安装Rabbitmq容器"></a>17、Docker：安装Rabbitmq容器</h2><blockquote><p>目标: 掌握在docker中安装rabbitmq容器</p></blockquote><p><strong>操作步骤</strong></p><ul><li><p>拉取镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 拉取rabbitmq镜像</span></span><br><span class="line">docker pull rabbitmq:management</span><br></pre></td></tr></table></figure></li><li><p>创建容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建Rabbitmq容器</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建容器，rabbitmq需要有映射以下端口:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 15672: web管理的端口</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5672：(客户端连接端口)</span></span><br><span class="line">docker run -di --name=myrabbitmq  -p 5672:5672 -p 15672:15672 rabbitmq:management</span><br><span class="line"></span><br><span class="line"><span class="meta"> #</span><span class="bash"> 查看日志</span></span><br><span class="line">docker logs -f myrabbit</span><br></pre></td></tr></table></figure><p><img src="/2020/03/16/Docker/1574230927161.png" alt="1574230927161"> </p></li><li><p>访问rabbit控制台: <a href="http://192.168.12.132:15672" target="_blank" rel="noopener">http://192.168.12.132:15672</a></p><p><img src="/2020/03/16/Docker/1574230965900.png" alt="1574230965900"> </p><p><img src="/2020/03/16/Docker/1574231068763.png" alt="1574231068763">  </p></li></ul><h2 id="18、Docker：容器备份与迁移"><a href="#18、Docker：容器备份与迁移" class="headerlink" title="18、Docker：容器备份与迁移"></a>18、Docker：容器备份与迁移</h2><blockquote><p>目标: 掌握docker中容器的备份与迁移</p></blockquote><p><img src="/2020/03/16/Docker/1574231546282.png" alt="1574231546282"> </p><p>主要作用: 就是让配置好的容器，可以得到复用，后面用到得的时候就不需要重新配置。</p><p>其中涉及到的命令有:</p><ul><li>docker commit 将容器保存为镜像 </li><li>docker save 将镜像备份为tar文件 </li><li>docker load 根据tar文件恢复为镜像</li></ul><p><strong>操作步骤</strong></p><ul><li><p>容器保存为镜像 (使用docker commit命令可以将容器保存为镜像)。 </p><p>命令格式: docker commit 容器名称 新的镜像名称</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将容器保存为镜像</span></span><br><span class="line"><span class="comment"># mynginx：容器名称、mynginx：新的镜像名称</span></span><br><span class="line">docker commit mynginx mynginx</span><br></pre></td></tr></table></figure><p><img src="/2020/03/16/Docker/1574232069718.png" alt="1574232069718"> </p><p>说明: 此镜像的内容就是当前容器的内容，接下来你可以用此镜像再次运行新的容器.</p></li><li><p>镜像备份 (使用docker save命令可以将已有镜像保存为tar文件)</p><p>命令格式: docker save –o tar文件名 镜像名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 保存镜像为文件 </span></span><br><span class="line">docker save -o mynginx.tar mynginx</span><br></pre></td></tr></table></figure><p><img src="/2020/03/16/Docker/1574232348861.png" alt="1574232348861"> </p></li><li><p>镜像恢复与迁移 (使用docker load命令可以根据tar文件恢复为docker镜像)</p><p>命令格式: docker load -i tar文件名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 停止mynginx容器 </span></span><br><span class="line">docker stop mynginx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除mynginx容器 </span></span><br><span class="line">docker rm mynginx </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除mynginx镜像 </span></span><br><span class="line">docker rmi mynginx </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 加载恢复mynginx镜像 </span></span><br><span class="line">docker load -i mynginx.tar </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在镜像恢复之后，基于该镜像再次创建启动容器 </span></span><br><span class="line">docker run -di --name=mynginx -p 80:80 mynginx</span><br></pre></td></tr></table></figure><p><img src="/2020/03/16/Docker/1574233036494.png" alt="1574233036494"> </p><p><img src="/2020/03/16/Docker/1574233127035.png" alt="1574233127035"> </p><p><img src="/2020/03/16/Docker/1574233194863.png" alt="1574233194863"> </p></li></ul><p><strong>总结</strong></p><ul><li>容器保存镜像: docker commit 容器名称 新的镜像的名称</li><li>导出镜像: docker save -o 镜像名称.tar 新的镜像的名称</li><li>导入镜像: docker load -i 镜像名称.tar</li></ul><h2 id="19、Docker：Dockerfile构建镜像"><a href="#19、Docker：Dockerfile构建镜像" class="headerlink" title="19、Docker：Dockerfile构建镜像"></a>19、Docker：Dockerfile构建镜像</h2><blockquote><p>目标: 掌握Dockerfile构建镜像</p></blockquote><h4 id="19-1-Dockerfile文件"><a href="#19-1-Dockerfile文件" class="headerlink" title="19.1 Dockerfile文件"></a>19.1 Dockerfile文件</h4><ul><li>前面的课程中已经知道了，要获得镜像，可以从Docker仓库中进行下载。那如果我们想自己开发一个镜像，那该如何做呢？答案是: Dockerfile </li><li>Dockerfile其实就是一个文本文件，由一系列命令和参数构成，Docker可以读取Dockerfile文件并根据Dockerfile文件的描述来构建镜像。</li><li>Dockerfile文件内容一般分为4部分<ul><li>基础镜像信息</li><li>维护者信息</li><li>镜像操作指令</li><li>容器启动时执行的指令</li></ul></li></ul><h4 id="19-2-常用命令"><a href="#19-2-常用命令" class="headerlink" title="19.2 常用命令"></a>19.2 常用命令</h4><table><thead><tr><th><strong>命令</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>FROM image_name:tag</td><td>定义了使用哪个基础镜像启动构建流程</td></tr><tr><td>MAINTAINER user_name</td><td>声明镜像的创建者</td></tr><tr><td>ENV key value</td><td>设置环境变量 (可以写多条)</td></tr><tr><td>RUN command</td><td>是Dockerfile的核心部分(可以写多条)</td></tr><tr><td>ADD source_dir/file dest_dir/file</td><td>将宿主机的文件复制到容器内，如果是一个压缩文件，将会在复制后自动解压</td></tr><tr><td>COPY source_dir/file dest_dir/file</td><td>和ADD相似，但是如果有压缩文件并不能解压</td></tr><tr><td>WORKDIR path_dir</td><td>设置工作目录</td></tr></tbody></table><h4 id="19-3-构建镜像"><a href="#19-3-构建镜像" class="headerlink" title="19.3 构建镜像"></a>19.3 构建镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1、创建目录 </span></span><br><span class="line">mkdir -p /usr/local/dockerjdk8 </span><br><span class="line">cd /usr/local/dockerjdk8 </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、下载jdk-8u171-linux-x64.tar.gz并上传到服务器（虚拟机）中的/usr/<span class="built_in">local</span>/dockerjdk8目录 </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3、在/usr/<span class="built_in">local</span>/dockerjdk8目录下创建Dockerfile文件，文件内容如下:</span></span><br><span class="line">vi Dockerfile</span><br><span class="line"></span><br><span class="line">FROM centos:7</span><br><span class="line">MAINTAINER ITCAST</span><br><span class="line">WORKDIR /usr</span><br><span class="line">RUN mkdir /usr/local/java</span><br><span class="line">ADD jdk-8u171-linux-x64.tar.gz /usr/local/java/</span><br><span class="line">ENV JAVA_HOME /usr/local/java/jdk1.8.0_171</span><br><span class="line">ENV JRE_HOME $JAVA_HOME/jre</span><br><span class="line">ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATH</span><br><span class="line">ENV PATH $JAVA_HOME/bin:$PATH</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4、执行命令构建镜像；不要忘了后面的那个 . </span></span><br><span class="line">docker build -t='jdk1.8' .</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5、查看镜像是否建立完成 </span></span><br><span class="line">docker images</span><br></pre></td></tr></table></figure><p>/usr/local/dockerjdk8/Dockerfile 文件中的内容:</p><p><img src="/2020/03/16/Docker/1574236736749.png" alt="1574236736749"> </p><p><img src="/2020/03/16/Docker/1574236923379.png" alt="1574236923379"> </p><p><img src="/2020/03/16/Docker/1574236957603.png" alt="1574236957603"> </p><p><img src="/2020/03/16/Docker/1574237020272.png" alt="1574237020272"> </p><blockquote><p>说明: 创建文件Dockerfile 这里的D必须大写，不能有任何的偏差。</p></blockquote><h4 id="19-4-镜像创建容器"><a href="#19-4-镜像创建容器" class="headerlink" title="19.4 镜像创建容器"></a>19.4 镜像创建容器</h4><p>基于刚刚创建的镜像 jdk1.8 创建并启动容器进行测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建并启动容器 </span></span><br><span class="line">docker run -it --name=testjdk jdk1.8 /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在容器中测试jdk是否已经安装 </span></span><br><span class="line">java -version</span><br></pre></td></tr></table></figure><p><img src="/2020/03/16/Docker/1574237271724.png" alt="1574237271724"> </p><h2 id="20、Docker：registry私服仓库"><a href="#20、Docker：registry私服仓库" class="headerlink" title="20、Docker：registry私服仓库"></a>20、Docker：registry私服仓库</h2><blockquote><p>目标: 掌握docker私服仓库搭建</p></blockquote><h4 id="20-1-私有仓库搭建与配置"><a href="#20-1-私有仓库搭建与配置" class="headerlink" title="20.1 私有仓库搭建与配置"></a>20.1 私有仓库搭建与配置</h4><p>Docker官方的Docker hub（<a href="https://hub.docker.com）是一个用于管理公共镜像的仓库，我们可以从上面拉取镜像到本地，也可以把我们自己的镜像推送上去。但是，有时候我们的服务器无法访问互联网，或者你不希望将自己的镜像放到公网当中，那么我们就需要搭建自己的私有仓库来存储和管理自己的镜像。" target="_blank" rel="noopener">https://hub.docker.com）是一个用于管理公共镜像的仓库，我们可以从上面拉取镜像到本地，也可以把我们自己的镜像推送上去。但是，有时候我们的服务器无法访问互联网，或者你不希望将自己的镜像放到公网当中，那么我们就需要搭建自己的私有仓库来存储和管理自己的镜像。</a></p><p>私有仓库搭建步骤:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1、拉取私有仓库镜像 </span></span><br><span class="line">docker pull registry</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、启动私有仓库容器</span></span><br><span class="line">docker run -di --name=registry -p 5000:5000 registry </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3、打开浏览器 输入地址http://宿主机ip:5000/v2/_catalog，看到&#123;<span class="string">"repositories"</span>:[]&#125; 表示私有仓库 搭建成功 </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4、修改daemon.json </span></span><br><span class="line">vi /etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在上述文件中添加一个key，保存退出。此步用于让 docker 信任私有仓库地址；注意将宿主机ip修改为自己宿主 机真实ip </span></span><br><span class="line">&#123;"insecure-registries":["宿主机ip:5000"]&#125; </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5、重启docker 服务 </span></span><br><span class="line">systemctl restart docker </span><br><span class="line"></span><br><span class="line">docker start registry</span><br></pre></td></tr></table></figure><p>访问: <a href="http://192.168.12.132:5000/v2/_catalog" target="_blank" rel="noopener">http://192.168.12.132:5000/v2/_catalog</a> </p><p><img src="/2020/03/16/Docker/1574238847936.png" alt="1574238847936"> </p><p><img src="/2020/03/16/Docker/1574238940458.png" alt="1574238940458"> </p><h4 id="20-2-将镜像上传至私有仓库"><a href="#20-2-将镜像上传至私有仓库" class="headerlink" title="20.2 将镜像上传至私有仓库"></a>20.2 将镜像上传至私有仓库</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1、标记镜像为私有仓库的镜像 </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 语法: docker tag jdk1.8 宿主机IP:5000/jdk1.8</span></span><br><span class="line">docker tag jdk1.8 192.168.12.132:5000/jdk1.8</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、再次启动私有仓库容器 </span></span><br><span class="line">docker restart registry </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3、上传标记的镜像到私有仓库</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 语法: docker push 宿主机IP:5000/jdk1.8 </span></span><br><span class="line">docker push 192.168.12.132:5000/jdk1.8</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4、输入网址查看仓库效果</span></span><br></pre></td></tr></table></figure><p><img src="/2020/03/16/Docker/1574239723576.png" alt="1574239723576"> </p><p><img src="/2020/03/16/Docker/1574239743318.png" alt="1574239743318"> </p><h4 id="20-3-从私有仓库拉取镜像"><a href="#20-3-从私有仓库拉取镜像" class="headerlink" title="20.3 从私有仓库拉取镜像"></a>20.3 从私有仓库拉取镜像</h4><p>若是在私有仓库所在的服务器上去拉取镜像；那么直接执行如下命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 因为私有仓库所在的服务器上已经存在相关镜像；所以先删除；请指定镜像名，不是id </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 语法: docker rmi 服务器ip:5000/jdk1.8</span></span><br><span class="line">docker rmi 192.168.12.132:5000/jdk1.8</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 拉取镜像 </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 语法: docker pull 服务器ip:5000/jdk1.8</span></span><br><span class="line">docker pull 192.168.12.132:5000/jdk1.8</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">可以通过如下命令查看 docker 的信息；了解到私有仓库地址 </span></span><br><span class="line">docker info</span><br></pre></td></tr></table></figure><p><img src="/2020/03/16/Docker/1574241484821.png" alt="1574241484821"> </p><p><img src="/2020/03/16/Docker/1574241554923.png" alt="1574241554923"> </p><h2 id="21、总结"><a href="#21、总结" class="headerlink" title="21、总结"></a>21、总结</h2><p>重点:</p><ul><li>docker 服务相关命令<ul><li>systemctl start docker</li><li>systemctl stop docker</li><li>systemctl restart docker</li><li>systemctl enable docker</li></ul></li><li>docker 镜像相关命令<ul><li>docker images</li><li>docker pull 镜像名称</li><li>docker rmi 镜像ID</li></ul></li><li>docker 容器相关命令<ul><li>docker ps | docker ps -a</li><li>docker run -it –name=容器名称 镜像名称:标签 /bin/bash (交互式)</li><li>docker run -id –name=容器名称 镜像名称:标签 (守护式)</li><li>docker exec -it 容器名称 /bin/bash</li><li>docker stop 容器名称</li><li>docker start 容器名称</li><li>docker restart 容器名称</li><li>docker inspect 容器名称 (查看容器ip)</li><li>docker rm 容器名称</li></ul></li><li>docker 容器文件拷贝<ul><li>docker cp abc.txt mycentos2:/ (从宿主机拷贝文件到容器)</li><li>docker cp mycentos2:/aaa.txt /root (从容器拷贝文件到宿主机)</li></ul></li><li>docker 容器目录挂载<ul><li>docker run -di -v /usr/local/test:/usr/local/test –name=mycentos3 centos:7</li></ul></li><li>docker 安装mysql容器<ul><li>拉取镜像，创建容器 (端口映射)</li></ul></li><li>docker 安装tomcat容器<ul><li>拉取镜像，创建容器 (端口映射)</li></ul></li><li>docker 安装nginx容器<ul><li>拉取镜像，创建容器 (端口映射)</li></ul></li><li>docker 安装redis容器<ul><li>拉取镜像，创建容器 (端口映射)</li></ul></li><li>docker 容器务份与迁移<ul><li>docker commit 将容器保存为镜像 </li><li>docker save 将镜像备份为tar文件 </li><li>docker load 根据tar文件恢复为镜像</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件安装</title>
      <link href="/2020/02/17/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
      <url>/2020/02/17/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><h4 id="1-Elasticsearch"><a href="#1-Elasticsearch" class="headerlink" title="1.Elasticsearch"></a>1.Elasticsearch</h4><p>​    可安装绿色版</p><p>​    双击bin目录下的elasticsearch.bat启动，IK分词器解压到plugins文件夹下</p><h5 id="kibana"><a href="#kibana" class="headerlink" title="kibana"></a>kibana</h5><p>​    双击bat文件启动</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>手术分类</title>
      <link href="/2020/02/17/%E6%89%8B%E6%9C%AF%E5%88%86%E7%B1%BB/"/>
      <url>/2020/02/17/%E6%89%8B%E6%9C%AF%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="肝胆胰外科"><a href="#肝胆胰外科" class="headerlink" title="肝胆胰外科"></a>肝胆胰外科</h3><h4 id="一级手术"><a href="#一级手术" class="headerlink" title="一级手术"></a>一级手术</h4><p>1、 简单开放性胆囊切除、胆囊造口术<br>2、 简单胆总管切开探查及造口术<br>3、 肝囊肿开窗及肝脓肿切开引流术<br>4、 急性胰腺炎引流手术及胰腺囊肿外引流术</p><h4 id="二级手术"><a href="#二级手术" class="headerlink" title="二级手术"></a>二级手术</h4><p>1、 较复杂的开放性胆囊切除术<br>2、 较复杂的胆总管切开探查及造口术<br>3、 一般胆囊、胆总管—十二指肠、空肠吻合术<br>4、 肝破裂修补、肝活检及肝边缘病灶切除术<br>5、 边缘肝切除、肝左外叶切除术<br>6、 肝囊肿内引流、胰腺假性囊肿内引流术<br>7、 胰尾切除、胰体尾裂伤手术及胰腺坏死组织清除及引流术<br>8、 腹腔镜胆囊切除及肝囊肿开窗<br>9、 脾切除术<br>10、 肝动脉结扎、栓塞及肝动脉、门静脉插管、化疗盒植入术<br>11、 Oddi括约肌成形术<br>12、 经皮肝穿胆管造影及引流术（PTC、PTCD）<br>13、 简单门体断流术</p><h4 id="三级手术"><a href="#三级手术" class="headerlink" title="三级手术"></a>三级手术</h4><p>1、 半肝切除术<br>2、 肝门部肝胆管成形及高位肝胆管空肠吻合术<br>3、 复杂或改进的胆总管空肠吻合术<br>4、 胆总管囊肿手术<br>5、 再次胆道手术<br>6、 腹腔镜胆道手术<br>7、 内镜、X光或超声引导下胆石、胆道狭窄支架手术<br>8、 胰十二指肠切除、全胰、胰头切除术<br>9、 胰头部复杂裂伤及胰十二指肠联合伤手术<br>10、 门腔静脉分流及复杂门体断流手术<br>11、 腹腔镜下肝边缘切除及脾切除术</p><h4 id="四级手术"><a href="#四级手术" class="headerlink" title="四级手术"></a>四级手术</h4><p>1、 肝移植受体手术<br>2、 半肝以上肝切除、肝中叶切除、肝尾状叶切除<br>3、 活体供肝切取术<br>4、 胰腺移植<br>5、 布—加综合征手术<br>6、 新技术新项目手术</p><h3 id="胃肠外科"><a href="#胃肠外科" class="headerlink" title="胃肠外科"></a>胃肠外科</h3><h4 id="一级手术-1"><a href="#一级手术-1" class="headerlink" title="一级手术"></a>一级手术</h4><p>1、 一般腹外疝修补术<br>2、 阑尾切除术<br>3、 胃十二指肠溃疡单纯修补术<br>4、 简单胃肠道破裂修补及造口术<br>5、 一般痔、肛瘘手术<br>6、 小肠吻合及其他腹腔、胃肠道简单手术</p><h4 id="二级手术-1"><a href="#二级手术-1" class="headerlink" title="二级手术"></a>二级手术</h4><p>1、 良性病变的胃、结肠切除及重建<br>2、 迷走神经切断手术<br>3、 简单门体静脉断流术<br>4、 十二指肠手术及广泛小肠切除术<br>5、 复杂疝修补术及人工补片疝修补术<br>6、 复杂痔、肛瘘手术<br>7、 弥漫性腹膜炎的剖腹探查术<br>8、 胃肠道瘘修补及造口闭合术<br>9、 一般消化道异物取出术</p><h4 id="三级手术-1"><a href="#三级手术-1" class="headerlink" title="三级手术"></a>三级手术</h4><p>1、 全胃、全（次全）结肠切除术<br>2、 胃癌、结肠癌、直肠癌根治术<br>3、 贲门部手术<br>4、 肛门、肛管成形手术<br>5、 腹部外伤休克状态下的探查术<br>6、 消化道出血休克状态下的探查术<br>7、 腹腔镜下胃肠穿孔修补及阑尾切除术<br>8、 复杂胃肠内镜治疗<br>9、 良性病变的一般腹腔镜胃肠道手术<br>10、 复杂及高危险消化道异物取出术<br>11、 巨大息肉摘除术</p><h4 id="四级手术-1"><a href="#四级手术-1" class="headerlink" title="四级手术"></a>四级手术</h4><p>1、 恶性肿瘤的腹腔镜胃、结直肠切除及消化道重建手术<br>2、 同种异体小肠移植<br>3、 腹腔镜下结直肠癌根治<br>4、 新技术新项目手术</p><h3 id="甲状腺外科"><a href="#甲状腺外科" class="headerlink" title="甲状腺外科"></a>甲状腺外科</h3><h4 id="一级手术-2"><a href="#一级手术-2" class="headerlink" title="一级手术"></a>一级手术</h4><p>1、 甲状腺腺瘤或囊肿切除<br>2、 甲状舌管囊肿切除<br>3、 甲状腺部分切除<br>4、 颈部淋巴管囊肿切除<br>5、 颈部肿块切除活检</p><h4 id="二级手术-2"><a href="#二级手术-2" class="headerlink" title="二级手术"></a>二级手术</h4><p>1、 甲状腺腺叶切除<br>2、 甲状腺大部或次全切除</p><h4 id="三级手术-2"><a href="#三级手术-2" class="headerlink" title="三级手术"></a>三级手术</h4><p>1、 甲状腺癌根治性切除术<br>2、 颈淋巴结清扫<br>3、 甲状腺全切除术<br>4、 胸骨后甲状腺切除<br>5、 甲状旁腺手术</p><h4 id="四级手术-2"><a href="#四级手术-2" class="headerlink" title="四级手术"></a>四级手术</h4><p>1、 腹腔镜甲状腺手术<br>2、 新技术新项目手术</p><h3 id="肛肠外科"><a href="#肛肠外科" class="headerlink" title="肛肠外科"></a>肛肠外科</h3><h4 id="一级手术-3"><a href="#一级手术-3" class="headerlink" title="一级手术"></a>一级手术</h4><p>1、 肛周皮下脓肿切开引流及一期根治术<br>2、 简单肛瘘切开，切除术或挂线疗法<br>3、 肛裂切除术<br>4、 肛乳头肥大切除术<br>5、 单纯内痔及血栓外痔切除术<br>6、 结肠造口术</p><h4 id="二级手术-3"><a href="#二级手术-3" class="headerlink" title="二级手术"></a>二级手术</h4><p>1、 结肠部分切除术<br>2、 经肛门直肠良性息肉切除术<br>3、 混合痔外剥内扎术<br>4、 乙状结肠扭转复位术<br>5、 吻合器痔上黏膜环切钉合术（PPH）<br>6、 藏毛窦囊肿和窦道切除术<br>7、 肛周Paget病手术<br>8、 造口旁疝修补术<br>9、 造口还纳术</p><h4 id="三级手术-3"><a href="#三级手术-3" class="headerlink" title="三级手术"></a>三级手术</h4><p>1、 右半，左半，横及乙状结肠癌根治术<br>2、 经腹或会阴直肠癌根治术<br>3、 直肠脱垂固定术<br>4、 直肠骶骨悬吊术<br>5、 直肠脱垂直肠周围硬化剂注射疗法<br>6、 肛门圈缩小术<br>7、 Ripstein, Goldberg, Aitemeir, Nigro手术<br>8、 复杂肛瘘切开或挂线术<br>9、 肛提肌上脓肿切开引流术<br>10、 经肛门或阴道直肠前突修补术<br>11、 结肠次全切除盲肠直肠吻合术<br>12、 Hartmann手术<br>13、 全结肠直肠节除，永久性回肠造口术</p><h4 id="四级手术-3"><a href="#四级手术-3" class="headerlink" title="四级手术"></a>四级手术</h4><p>1、 直肠癌扩大根治术<br>2、 改变Bacon手术<br>3、 后盆腔切除术<br>4、 全盆腔清扫术<br>5、 合结肠切除，回肠贮袋肛管吻合术<br>6、 腹腔镜下结直肠癌根治术<br>7、 各种结直肠或肛门术后出现并发症需再次手术者<br>8、 新技术新项目的手术</p><h3 id="血管外科"><a href="#血管外科" class="headerlink" title="血管外科"></a>血管外科</h3><h4 id="一级手术-4"><a href="#一级手术-4" class="headerlink" title="一级手术"></a>一级手术</h4><p>1、 动、静脉插管术<br>2、 血管缝合术<br>3、 浅表静脉手术</p><h4 id="二级手术-4"><a href="#二级手术-4" class="headerlink" title="二级手术"></a>二级手术</h4><p>1、 外周动、静脉取栓术<br>2、 血管吻合手术<br>3、 外周较小动、静脉瘤切除术<br>4、 简单静脉段移植术<br>5、 大隐静脉和股浅静脉瓣膜环缩术<br>6、 大隐静脉激光腔内治疗术和旋切术<br>7、 股深静脉瓣膜成型术</p><h4 id="三级手术-4"><a href="#三级手术-4" class="headerlink" title="三级手术"></a>三级手术</h4><p>1、动脉大隐静脉搭桥术<br>2、 动脉人工血管架桥术<br>3、 四肢动脉瘤切除术<br>4、 颈动脉内膜切除术<br>5、 一般下腔静脉手术</p><h4 id="四级手术-4"><a href="#四级手术-4" class="headerlink" title="四级手术"></a>四级手术</h4><p>1、 胸主动脉瘤及腹主动脉瘤手术<br>2、 复杂下腔静脉手术<br>3、 颈部动脉瘤手术<br>4、 颈动脉体瘤手术<br>5、 血管镜手术<br>6、 新技术新项目手术</p><h3 id="乳腺外科"><a href="#乳腺外科" class="headerlink" title="乳腺外科"></a>乳腺外科</h3><h4 id="一级手术-5"><a href="#一级手术-5" class="headerlink" title="一级手术"></a>一级手术</h4><p>1、 乳腺脓肿引流<br>2、 乳腺活检<br>3、 乳腺良性肿瘤切除<br>4、 乳腺外伤手术</p><h4 id="二级手术-5"><a href="#二级手术-5" class="headerlink" title="二级手术"></a>二级手术</h4><p>1、 乳腺单纯切除术<br>2、 乳腺区段切除术<br>3、 导管内乳头状瘤切除术</p><h4 id="三级手术-5"><a href="#三级手术-5" class="headerlink" title="三级手术"></a>三级手术</h4><p>1、 乳腺癌根治术及改良根治术<br>2、 乳房成型术<br>3、 乳房重建术<br>4、 保乳手术</p><h4 id="四级手术-5"><a href="#四级手术-5" class="headerlink" title="四级手术"></a>四级手术</h4><p>1、 乳腺癌扩大根治术<br>2、新技术新项目手术</p>]]></content>
      
      
      <categories>
          
          <category> 李惠程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 医学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>糖尿病饮食原则</title>
      <link href="/2020/02/17/%E7%B3%96%E5%B0%BF%E7%97%85%E9%A5%AE%E9%A3%9F%E5%8E%9F%E5%88%99/"/>
      <url>/2020/02/17/%E7%B3%96%E5%B0%BF%E7%97%85%E9%A5%AE%E9%A3%9F%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h3 id="糖尿病饮食原则"><a href="#糖尿病饮食原则" class="headerlink" title="糖尿病饮食原则"></a>糖尿病饮食原则</h3><h5 id="1-少食多餐，合理搭配"><a href="#1-少食多餐，合理搭配" class="headerlink" title="1.少食多餐，合理搭配"></a>1.少食多餐，合理搭配</h5><p>每天至少早、中、晚三餐，可以按1/5、2/5、2/5分配，适当加1-2餐，少食多餐可以保证全日血糖相对平稳，而不至于造成急剧高血糖：同时保证生成的热能尽快散发(吃多少用多少)，避免热能聚集转化为脂肪。</p><h5 id="2-规则进餐"><a href="#2-规则进餐" class="headerlink" title="2.规则进餐"></a>2.规则进餐</h5><p>按时按量有规则的进餐，一方面有助于内分泌和代谢的稳定，另一方面可以促进药物治疗方案有效的调整。</p><h5 id="3-饮食均衡"><a href="#3-饮食均衡" class="headerlink" title="3.饮食均衡"></a>3.饮食均衡</h5><p>一天的食谱要尽量包括四大类食物：粮谷类、蔬菜果类、禽肉类和奶豆类。在各类食物中选择不同的食物使饮食丰富多彩。</p><h5 id="4-饮食清淡少盐"><a href="#4-饮食清淡少盐" class="headerlink" title="4.饮食清淡少盐"></a>4.饮食清淡少盐</h5><p>少用煎炸的烹调方式，不吃可见脂肪的肉类；烹调用植物油，味道清淡，少放调味品。</p><h5 id="5-水果和蔬菜"><a href="#5-水果和蔬菜" class="headerlink" title="5.水果和蔬菜"></a>5.水果和蔬菜</h5><p>虽然两者都含丰富的膳食纤维和维生素C蔬菜含糖量较水果低，但蔬菜中的维生素易被破坏，而水果中的维生素则能较好保留。另外，水果一般在餐后2小时进食较好，且选用一些血糖生成指数较低的水果，例如：樱桃、李子、鲜桃、柚子、苹果、石榴、梨、火龙果、蓝莓、小番茄等。</p><h5 id="6、汤水不能代替肉类。"><a href="#6、汤水不能代替肉类。" class="headerlink" title="6、汤水不能代替肉类。"></a>6、汤水不能代替肉类。</h5><p>肉汤中的营养成分低，只含少量的含氨基酸浸出物、嘌呤、肉类中的大部分脂肪，故汤水只能适当使用，而且要忌油腻。</p><h5 id="7、限制单、双糖。"><a href="#7、限制单、双糖。" class="headerlink" title="7、限制单、双糖。"></a>7、限制单、双糖。</h5><p>碳水化合物分为单糖(例如：葡萄糖、半乳糖、果糖)、双糖(例如：蔗糖、麦芽糖和乳糖)和多糖。单、双糖统称为简单糖。简单糖食物在体内很快吸收，导致食后血糖急剧增高(0.5小时)，对于糖尿病人病情不利，应该尽量避免进食此类食物和食品。</p><h5 id="8、粮谷类粗细搭配。"><a href="#8、粮谷类粗细搭配。" class="headerlink" title="8、粮谷类粗细搭配。"></a>8、粮谷类粗细搭配。</h5><p>高热量值的精白米、面内可掺入低热量值的荞麦、燕麦、黑米、红米、高粱、青稞等。</p><p>具体饮食指导：</p><p>早餐：6-7个蒸饺/4-5个小笼包/碗无糖麦片/小碗蛋炒饭(少油少盐)+3-5个小西红柿/半根黄瓜。不要食用稀饭、米粉(包括红薯粉及土豆粉等各种粉类)、面条、油条、油饼、馒头、玉米等。</p><p>中、晚餐：米饭1-2两+蔬菜(各类叶子菜、黄瓜、苦瓜等，不含根茎类)2-4两+肉类(猪肉、鸡肉、鱼肉、牛肉均可)1-2两。注意少油少盐，不要食用煎炸食物。尽量不喝汤，如果无法改变饮食习惯，可在饭前喝一小碗汤。不要食用汤泡饭或茶泡饭。</p>]]></content>
      
      
      <categories>
          
          <category> 李惠程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 医学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch</title>
      <link href="/2020/02/16/Elasticsearch/"/>
      <url>/2020/02/16/Elasticsearch/</url>
      
        <content type="html"><![CDATA[<h2 id="01、ElasticSearch简介"><a href="#01、ElasticSearch简介" class="headerlink" title="01、ElasticSearch简介"></a>01、ElasticSearch简介</h2><h4 id="1-1-什么是ElasticSearch"><a href="#1-1-什么是ElasticSearch" class="headerlink" title="1.1 什么是ElasticSearch"></a>1.1 什么是ElasticSearch</h4><p>Elaticsearch，简称为es，es是一个开源的高扩展的分布式全文搜索服务，它可以近乎实时的存储、检索数据；本身扩展性很好，可以扩展到上百台服务器，处理PB级别的数据。es也是使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。1PB=1024TB</p><h4 id="1-2-ElasticSearch使用案例"><a href="#1-2-ElasticSearch使用案例" class="headerlink" title="1.2 ElasticSearch使用案例"></a>1.2 ElasticSearch使用案例</h4><ul><li>2013年初，GitHub抛弃了Solr，采取ElasticSearch来做PB级的搜索。“GitHub使用ElasticSearch搜索20TB的数据，包括13亿文件和1300亿行代码”。</li><li>维基百科：启动以elasticsearch为基础的核心搜索架构。</li><li>SoundCloud：“SoundCloud使用ElasticSearch为1.8亿用户提供即时而精准的音乐搜索服务”。</li><li>百度：百度目前广泛使用ElasticSearch作为文本数据分析，采集百度所有服务器上的各类指标数据及用户自定义数据，通过对各种数据进行多维分析展示，辅助定位分析实例异常或业务层面异常。目前覆盖百度内部20多个业务线（包括casio、云分析、网盟、预测、文库、直达号、钱包、风控等），单集群最大100台机器，200个ES节点，每天导入30TB+数据。</li><li>新浪使用ES 分析处理32亿条实时日志。</li><li>阿里使用ES  构建挖财自己的日志采集和分析体系。</li></ul><h4 id="1-3-ElasticSearch对比Solr"><a href="#1-3-ElasticSearch对比Solr" class="headerlink" title="1.3 ElasticSearch对比Solr"></a>1.3 ElasticSearch对比Solr</h4><ul><li>Solr利用 Zookeeper 进行分布式管理，而 Elasticsearch 自身带有分布式协调管理功能。</li><li>Solr支持更多格式的数据，而Elasticsearch仅支持json文件格式。</li><li>Solr官方提供的功能更多，而Elasticsearch本身更注重于核心功能，高级功能都有第三方插件提供。</li><li>Solr在传统的搜索应用中表现好于Elasticsearch，但在处理实时搜索应用时效率明显低于  Elasticsearch当单纯的对已有数据进行搜索时，Solr更快,当实时建立索引时, Solr会产生io阻塞，查询性能较差, Elasticsearch具有明显的优势。随着数据量的增加，Solr的搜索效率会变得更低，而Elasticsearch却没有明显的变化。综上所述，<strong>Solr的架构不适合实时搜索的应用</strong>。Solr是传统搜索应用的有力解决方案，但 <strong>Elasticsearch 更适用于新兴的实时搜索应用</strong>。</li></ul><h2 id="02、ElasticSearch：安装-amp-启动"><a href="#02、ElasticSearch：安装-amp-启动" class="headerlink" title="02、ElasticSearch：安装&amp;启动"></a>02、ElasticSearch：安装&amp;启动</h2><h4 id="2-1-下载"><a href="#2-1-下载" class="headerlink" title="2.1 下载"></a>2.1 下载</h4><ul><li><p>ElasticSearch分为Linux和Window版本，基于我们主要学习的是ElasticSearch的Java客户端的使用，所以我们课程中使用的是安装较为简便的Window版本，项目上线后，公司的运维人员会安装Linux版的ES供我们连接使用。</p></li><li><p>ElasticSearch官方地址：<a href="https://www.elastic.co/products/elasticsearch" target="_blank" rel="noopener">https://www.elastic.co/cn/products/elasticsearch</a></p><p><img src="/2020/02/16/Elasticsearch/1573459143961.png" alt="01"></p><p><img src="/2020/02/16/Elasticsearch/1573459250193.png" alt="1573459250193"></p><p><img src="/2020/02/16/Elasticsearch/1573459372487.png" alt="03"></p><p><img src="/2020/02/16/Elasticsearch/1573459444499.png" alt="04"> </p><p>在“资料”中已经提供了下载好的elasticsearch-6.2.2.zip压缩包</p><p><img src="/2020/02/16/Elasticsearch/1573460192291.png" alt="05"> </p></li></ul><h4 id="2-2-安装"><a href="#2-2-安装" class="headerlink" title="2.2 安装"></a>2.2 安装</h4><p>Window版的ElasticSearch的安装很简单，类似Window版的Tomcat，解压开即安装完毕，解压后的ElasticSearch的目录结构如下:</p><p><img src="/2020/02/16/Elasticsearch/1573460207272.png" alt="1573460207272"> </p><h4 id="2-3-启动"><a href="#2-3-启动" class="headerlink" title="2.3 启动"></a>2.3 启动</h4><p>进入elasticsearch-6.6.2\bin目录，点击elasticsearch.bat启动:</p><p><img src="/2020/02/16/Elasticsearch/1572261981080.png" alt="1573460314105"> </p><p><img src="/2020/02/16/Elasticsearch/1573462020231.png" alt="1573462020231"> </p><p><img src="/2020/02/16/Elasticsearch/1573461655107.png" alt="1573461655107"> </p><p><strong>注意：启动时可能会出现JVM堆内存不够的错误。需修改elasticsearch-6.6.2/config目录下的配置文件jvm.options</strong></p><p><img src="/2020/02/16/Elasticsearch/1573460440883.png" alt="1573460440883"> </p><p>浏览器访问：<code>http://localhost:9200</code> 看到如下返回的json信息，代表ES服务启动成功:</p><p><img src="/2020/02/16/Elasticsearch/1573460766189.png" alt="1573460766189"> </p><blockquote><p><strong>注意：ElasticSearch是用java开发的，且本版本的es需要的jdk版本要是JDK1.8+，并配置好JDK环境变量，否则启动ElasticSearch失败。</strong> </p></blockquote><h2 id="03、ElasticSearch：管理应用部署"><a href="#03、ElasticSearch：管理应用部署" class="headerlink" title="03、ElasticSearch：管理应用部署"></a>03、ElasticSearch：管理应用部署</h2><p>ElasticSearch不同于Solr自带图形化界面，我们可以通过安装ElasticSearch的head插件，完成图形化界面的效果，完成索引数据的查看。在资料中已经提供了head插件压缩包。</p><ul><li><p>下载head插件：<code>https://github.com/mobz/elasticsearch-head</code></p><p><img src="/2020/02/16/Elasticsearch/1573462353305.png" alt="1573462353305"> </p></li><li><p>部署elasticsearch-head-master插件</p><ul><li><p>拷贝apache-tomcat-8.5.28.zip到D:\es目录下解压，更名为tomcat-head</p><p><img src="/2020/02/16/Elasticsearch/1573462523115.png" alt="1573462523115"> </p></li><li><p>删除tomcat-head\webapps目录下全部项目</p><p><img src="/2020/02/16/Elasticsearch/1573462635549.png" alt="1573462635549"> </p></li><li><p>拷贝“资料”目录下的elasticsearch-head-master.zip到D:\es\tomcat-head\webapps目录下，解压，更名为ROOT</p><p><img src="/2020/02/16/Elasticsearch/1573462711945.png" alt="1573462711945"> </p></li><li><p>启动tomcat，打开浏览器输入 <code>http://localhost:8080</code>，看到如下页面:</p><p><img src="/2020/02/16/Elasticsearch/1573463206657.png" alt="1573463206657"> </p></li><li><p>head管理应用默认连接不上ES服务端的，会报以下错误：</p><p><img src="/2020/02/16/Elasticsearch/1573463286436.png" alt="1573463286436"> </p><p>原因: Elasticsearch-head  跨域 访问ES服务端，产生跨域请求错误。</p></li></ul></li><li><p>配置ES服务端允许跨域访问</p><p>修改elasticsearch-6.6.2\config目录下的elasticsearch.yml，增加以下配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置跨域</span></span><br><span class="line"><span class="meta">http.cors.enabled</span>: <span class="string">true </span></span><br><span class="line"><span class="meta">http.cors.allow-origin</span>: <span class="string">"*"</span></span><br></pre></td></tr></table></figure><p><img src="/2020/02/16/Elasticsearch/wps1.jpg" alt="img"> </p><p>重新启动ES服务，用Head插件连接ES服务，效果如下：</p><p><img src="/2020/02/16/Elasticsearch/wps2.jpg" alt="img"></p></li></ul><h2 id="04、ElasticSearch：核心概念"><a href="#04、ElasticSearch：核心概念" class="headerlink" title="04、ElasticSearch：核心概念"></a>04、ElasticSearch：核心概念</h2><blockquote><p>目标: 了解ElasticSearch的相关概念: 集群、节点、索引、类型、文档、分片、映射是什么？</p></blockquote><h4 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h4><p>Elasticsearch面向文档(document oriented)的，这意味着它可以存储整个对象或文档(document)。然而它不仅仅是存储，还会索引(index)每个文档的内容使之可以被搜索。在Elasticsearch中，你可以对文档进行索引、搜索、排序、过滤。</p><p>关系型数据库与ES索引库类比:</p><table><thead><tr><th>关系型数据库</th><th>数据库</th><th>表</th><th>行</th><th>列</th></tr></thead><tbody><tr><td>Relational DB</td><td>Databases</td><td>Tables</td><td>Rows</td><td>Columns</td></tr></tbody></table><table><thead><tr><th>ES服务</th><th>索引库</th><th>类型</th><th>文档</th><th>字段</th></tr></thead><tbody><tr><td>ElasticSearch</td><td>Indices</td><td>Types</td><td>Documents</td><td>Fields</td></tr></tbody></table><h4 id="4-2-核心概念"><a href="#4-2-核心概念" class="headerlink" title="4.2 核心概念"></a>4.2 核心概念</h4><p><img src="/2020/02/16/Elasticsearch/1551061589694.png" alt="1551061589694"> </p><ul><li><p><strong>近实时 NRT</strong>(Near Realtime)–速度快</p><p>Elasticsearch是一个接近实时的搜索平台。这意味着，从索引一个文档直到这个文档能够被搜索到有一个轻微的延迟（通常是1秒以内）</p></li><li><p><strong>集群 cluster</strong></p><p>一个集群就是由一个或多个节点组织在一起，它们共同持有整个的数据，并一起提供索引和搜索功能。一个集群由一个唯一的名字标识，==这个名字默认就是“elasticsearch”。==这个名字是重要的，因为一个节点只能通过指定某个集群的名字，来加入这个集群。</p></li><li><p><strong>节点 node</strong></p><p>一个节点是集群中的一个服务器，作为集群的一部分，它存储数据，参与集群的索引和搜索功能。和集群类似，一个节点也是由一个名字来标识的，默认情况下，这个名字是一个随机的漫威漫画角色的名字，这个名字会在启动的时候赋予节点。这个名字对于管理工作来说挺重要的，因为在这个管理过程中，你会去确定网络中的哪些服务器对应于Elasticsearch集群中的哪些节点。 一个节点可以通过配置集群名称的方式来加入一个指定的集群。默认情况下，每个节点都会被安排加入到一个叫 做“elasticsearch”的集群中，这意味着，如果你在你的网络中启动了若干个节点，并假定它们能够相互发现彼此， 它们将会自动地形成并加入到一个叫做“elasticsearch”的集群中。 在一个集群里，只要你想，可以拥有任意多个节点。而且，如果当前你的网络中没有运行任何Elasticsearch节点， 这时启动一个节点，会默认创建并加入一个叫做“elasticsearch”的集群。</p></li><li><p><strong>索引 index(重点)</strong>–索引库</p><ul><li>几分相似特征的文档的集合。比如说，你可以有一个客户数据的索引，另一个产品目录的索引，还有一个订单数据的索引。一个索引由一个名字来标识（必须全部是小写字母的），并且当我们要对对应于这个索引中的文档进行索引、搜索、更新和删除的时候，都要使用到这个名字。在一个集群中，可以定义任意多的索引。</li><li>一个索引就是一个拥有几分相似特征的文档的集合。比如说，你可以有一个客户数据的索引，另一个产品目录的索引，还有一个订单数据的索引。一个索引由一个名字来标识（必须全部是小写字母的），并且当我们要对对应于这个索引中的文档进行索引、搜索、更新和删除的时候，都要使用到这个名字。在一个集群中，可以定义任意多的索引。</li></ul></li><li><p><strong>类型 type(重点)</strong>–表</p><p>在一个索引中，你只能定义一种类型。一个类型是你的索引的一个逻辑上的分类/分区，其语义完全由你来定。通常，会为具有一组共同字段的文档定义一个类型。比如说，我们假设你运营一个博客平台并且将你所有的数据存储到一个索引中。在这个索引中，你可以为用户数据定义一个类型，为博客数据定义另一个类型，当然，也可以为评论数据定义另一个类型。</p></li><li><p><strong>文档 document(重点)</strong>–json</p><p>一个文档是一个可被索引的基础信息单元。比如，你可以拥有某一个客户的文档，某一个产品的一个文档，当然，也可以拥有某个订单的一个文档。文档以JSON（Javascript Object Notation）格式来表示，而JSON是一个到处存在的互联网数据交互格式。 在一个index/type里面，你可以存储任意多的文档。注意，尽管一个文档，物理上存在于一个索引之中，文档必须 被索引/赋予一个索引的type。</p></li><li><p><strong>分片和复制shards&amp;replicas</strong>–自我、修复、备份</p><p>一个索引可以存储超出单个节点硬件限制的大量数据。比如，一个具有10亿文档的索引占据1TB的磁盘空间，而任一节点都没有这样大的磁盘空间；或者单个节点处理搜索请求，响应太慢。为了解决这个问题，Elasticsearch提供了将索引划分成多份的能力，这些份就叫做分片。当你创建一个索引的时候，你可以指定你想要的分片的数量。每个分片本身也是一个功能完善并且独立的“索引”，这个“索引”可以被放置到集群中的任何节点上。分片很重要，主要有两方面的原因：</p><ul><li>允许你水平分割/扩展你的内容容量。</li><li>允许你在分片（潜在地，位于多个节点上）之上进行分布式的、并行的操作，进而提高性能/吞吐量。至于一个分片怎样分布，它的文档怎样聚合回搜索请求，是完全由Elasticsearch管理的，对于作为用户的你来说，这些都是透明的。在一个网络/云的环境里，失败随时都可能发生，在某个分片/节点不知怎么的就处于离线状态，或者由于任何原因消失了，这种情况下，有一个故障转移机制是非常有用并且是强烈推荐的。为此目的，Elasticsearch允许你创建分片的一份或多份拷贝，这些拷贝叫做复制分片，或者直接叫复制。复制之所以重要，有两个主要原因： 在分片/节点失败的情况下，提供了高可用性。因为这个原因，注意到复制分片从不与原/主要（original/primary）分片置于同一节点上是非常重要的。扩展你的搜索量/吞吐量，因为搜索可以在所有的复制上并行运行。总之，每个索引可以被分成多个分片。一个索引也可以被复制0次（意思是没有复制）或多次。一旦复制了，每个索引就有了主分片（作为复制源的原来的分片）和复制分片（主分片的拷贝）之别。分片和复制的数量可以在索引创建的时候指定。在索引创建之后，你可以在任何时候动态地改变复制的数量，但是你事后不能改变分片的数量。默认情况下，Elasticsearch中的每个索引被分片5个主分片和1个复制，这意味着，如果你的集群中至少有两个节点，你的索引将会有5个主分片和另外5个复制分片（1个完全拷贝），这样的话每个索引总共就有10个分片。</li></ul></li><li><p><strong>映射 mapping(重点)</strong></p><p>mapping是处理数据的方式和规则方面做一些限制，如某个字段的数据类型、默认值、分析器、是否被索引等等，这些都是映射里面可以设置的，其它就是处理es里面数据的一些使用规则设置也叫做映射，按着最优规则处理数据对性能提高很大，因此才需要建立映射，并且需要思考如何建立映射才能对性能更好？和建立表结构表关系数据库三范式类似。【是否分词、是否索引、是否存储】</p></li></ul><h4 id="4-3-小结"><a href="#4-3-小结" class="headerlink" title="4.3 小结"></a>4.3 小结</h4><ul><li><p>什么是集群</p></li><li><blockquote><p>给所有的es节点，定义一个相同的名字: 默认名字是elasticsearch,就可以自动转换成集群。</p></blockquote></li><li><p>什么是节点</p><blockquote><p>每一个es服务就是一个节点。只要节点名字不相同，就可以形成一个集群。</p></blockquote></li><li><p>什么是索引(Indices)（重点）</p><blockquote><p>一个索引就是一个拥有相似特征的文档的集合,（足够灵活。数据结构可以不一样）。</p></blockquote></li><li><p>什么是类型(Types)（重点）</p><blockquote><p>类型数据的表，进行文档的区分。</p></blockquote></li><li><p>什么是文档(Document)（重点）</p><blockquote><p>数据存储的结构，数据结构：json</p></blockquote></li><li><p>什么是映射(Mapping)</p><blockquote><p>是定义文档数据结构的属性的规范。比如属性：是否要存储，是否要索引，采用什么样的分词等。</p></blockquote></li></ul><h2 id="05、ElasticSearch：搭建测试环境"><a href="#05、ElasticSearch：搭建测试环境" class="headerlink" title="05、ElasticSearch：搭建测试环境"></a>05、ElasticSearch：搭建测试环境</h2><h4 id="5-1-创建测试模块"><a href="#5-1-创建测试模块" class="headerlink" title="5.1 创建测试模块"></a>5.1 创建测试模块</h4><p><img src="/2020/02/16/Elasticsearch/1573466182754.png" alt="1573466182754"></p><h4 id="5-2-配置依赖"><a href="#5-2-配置依赖" class="headerlink" title="5.2 配置依赖"></a>5.2 配置依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>transport<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="5-3-提供log4j2-xml"><a href="#5-3-提供log4j2-xml" class="headerlink" title="5.3 提供log4j2.xml"></a>5.3 提供log4j2.xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span> <span class="attr">status</span>=<span class="string">"warn"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">"Console"</span> <span class="attr">target</span>=<span class="string">"SYSTEM_OUT"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"%m%n"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">"INFO"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"Console"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="06、ElasticSearch：创建索引库"><a href="#06、ElasticSearch：创建索引库" class="headerlink" title="06、ElasticSearch：创建索引库"></a>06、ElasticSearch：创建索引库</h2><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><blockquote><p>掌握创建索引库的代码实现</p></blockquote><h4 id="编程步骤"><a href="#编程步骤" class="headerlink" title="编程步骤"></a>编程步骤</h4><ul><li>创建Settings配置信息对象</li><li>创建ES传输客户端对象</li><li>使用传输客户端对象创建索引库</li><li>释放资源</li></ul><h4 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.elasticsearch.client.transport.TransportClient;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.common.settings.Settings;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.common.transport.TransportAddress;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.transport.client.PreBuiltTransportClient;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 创建索引库 */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建Settings配置信息对象(主要配置集群名称)</span></span><br><span class="line">        <span class="comment">// 参数一: 集群key (固定不变)</span></span><br><span class="line">        <span class="comment">// 参数二：集群环境名称,默认的ES的环境集群名称为 "elasticsearch"</span></span><br><span class="line">        Settings settings = Settings.builder()</span><br><span class="line">                .put(<span class="string">"cluster.name"</span>, <span class="string">"elasticsearch"</span>).build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建ES传输客户端对象</span></span><br><span class="line">        TransportClient transportClient = <span class="keyword">new</span> PreBuiltTransportClient(settings);</span><br><span class="line">        <span class="comment">// 2.1 添加传输地址对象</span></span><br><span class="line">        <span class="comment">// 参数一：主机</span></span><br><span class="line">        <span class="comment">// 参数二：端口</span></span><br><span class="line">        transportClient.addTransportAddress(<span class="keyword">new</span> TransportAddress(</span><br><span class="line">                InetAddress.getByName(<span class="string">"127.0.0.1"</span>), <span class="number">9300</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 创建索引库(index)</span></span><br><span class="line">        <span class="comment">// 获取索引库管理客户端执行创建索引库，并执行请求</span></span><br><span class="line">        transportClient.admin().indices().prepareCreate(<span class="string">"blog1"</span>).get();</span><br><span class="line">        <span class="comment">// 4. 释放资源</span></span><br><span class="line">        transportClient.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/16/Elasticsearch/1573482309057.png" alt="1573482309057">   </p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><blockquote><p>创建索引库核心代码:</p><p><strong>transportClient.admin().indices().prepareCreate(“book”).get();</strong></p></blockquote><h2 id="07、ElasticSearch：添加文档"><a href="#07、ElasticSearch：添加文档" class="headerlink" title="07、ElasticSearch：添加文档"></a>07、ElasticSearch：添加文档</h2><blockquote><p>目标: 掌握 文档增加 的代码实现</p></blockquote><h4 id="7-1-第一种方式"><a href="#7-1-第一种方式" class="headerlink" title="7.1 第一种方式"></a>7.1 第一种方式</h4><p><strong>编程步骤</strong></p><ul><li>创建Settings配置信息对象</li><li>创建ES传输客户端对象</li><li>创建文档对象，创建一个json格式的字符串，或者使用XContentBuilder</li><li>传输客户端对象把文档添加到索引库中</li><li>释放资源</li></ul><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 添加文档: 第一种方式(XContentBuilder) */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建Settings配置信息对象</span></span><br><span class="line">    Settings settings = Settings.builder()</span><br><span class="line">        .put(<span class="string">"cluster.name"</span>, <span class="string">"elasticsearch"</span>).build();</span><br><span class="line">    <span class="comment">// 2. 创建ES传输客户端对象</span></span><br><span class="line">    TransportClient transportClient = <span class="keyword">new</span> PreBuiltTransportClient(settings);</span><br><span class="line">    <span class="comment">// 2.1 添加传输地址对象</span></span><br><span class="line">    transportClient.addTransportAddress(<span class="keyword">new</span></span><br><span class="line">         TransportAddress(InetAddress.getByName(<span class="string">"127.0.0.1"</span>), <span class="number">9300</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 创建内容构建对象</span></span><br><span class="line">    XContentBuilder builder = XContentFactory.jsonBuilder()</span><br><span class="line">        .startObject()</span><br><span class="line">        .field(<span class="string">"id"</span>, <span class="number">1</span>)</span><br><span class="line">        .field(<span class="string">"title"</span>, <span class="string">"elasticsearch搜索服务"</span>)</span><br><span class="line">        .field(<span class="string">"content"</span>,<span class="string">"ElasticSearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎。"</span>)</span><br><span class="line">        .endObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 执行索引库、类型、文档</span></span><br><span class="line">    transportClient.prepareIndex(<span class="string">"blog1"</span>,<span class="string">"article"</span>, <span class="string">"1"</span>)</span><br><span class="line">        .setSource(builder).get(); <span class="comment">// 执行请求</span></span><br><span class="line">    <span class="comment">// 5. 释放资源</span></span><br><span class="line">    transportClient.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-2-第二种方式"><a href="#7-2-第二种方式" class="headerlink" title="7.2 第二种方式"></a>7.2 第二种方式</h4><p><strong>编程步骤</strong></p><ul><li>创建Settings配置信息对象</li><li>创建ES传输客户端对象</li><li>创建Map集合，封装文档数据</li><li>传输客户端对象把文档添加到索引库中</li><li>释放资源</li></ul><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 创建文档: 第二种方式(使用Map集合) */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建Settings配置信息对象</span></span><br><span class="line">    Settings settings = Settings.builder()</span><br><span class="line">        .put(<span class="string">"cluster.name"</span>, <span class="string">"elasticsearch"</span>).build();</span><br><span class="line">    <span class="comment">// 2. 创建ES传输客户端对象</span></span><br><span class="line">    TransportClient transportClient = <span class="keyword">new</span> PreBuiltTransportClient(settings);</span><br><span class="line">    <span class="comment">// 2.1 添加传输地址对象</span></span><br><span class="line">    transportClient.addTransportAddress(<span class="keyword">new</span> TransportAddress(</span><br><span class="line">        InetAddress.getByName(<span class="string">"127.0.0.1"</span>), <span class="number">9300</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 定义Map集合封装文档</span></span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">    map.put(<span class="string">"id"</span>, <span class="number">2</span>);</span><br><span class="line">    map.put(<span class="string">"title"</span>, <span class="string">"dubbo分布式服务框架"</span>);</span><br><span class="line">    map.put(<span class="string">"content"</span>, <span class="string">"dubbo阿里巴巴开源的高性能的RPC框架。"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 添加文档</span></span><br><span class="line">    transportClient.prepareIndex(<span class="string">"blog1"</span>,<span class="string">"article"</span>, <span class="string">"2"</span>)</span><br><span class="line">        .setSource(map).get();</span><br><span class="line">    <span class="comment">// 5. 释放资源</span></span><br><span class="line">    transportClient.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-3-第三种方式"><a href="#7-3-第三种方式" class="headerlink" title="7.3 第三种方式"></a>7.3 第三种方式</h4><p><strong>准备工作</strong></p><ul><li><p>引入jackson依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>定义pojo实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Article</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>编程步骤</strong></p><ul><li>创建Settings配置信息对象</li><li>创建ES传输客户端对象</li><li>创建pojo对象，封装文档数据</li><li>把实体对象转化成json字符串</li><li>传输客户端对象把文档添加到索引库中</li><li>释放资源</li></ul><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 创建文档: 第三种方式(使用POJO) */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建Settings配置信息对象</span></span><br><span class="line">    Settings settings = Settings.builder()</span><br><span class="line">        .put(<span class="string">"cluster.name"</span>, <span class="string">"elasticsearch"</span>).build();</span><br><span class="line">    <span class="comment">// 2. 创建ES传输客户端对象</span></span><br><span class="line">    TransportClient transportClient = <span class="keyword">new</span> PreBuiltTransportClient(settings);</span><br><span class="line">    <span class="comment">// 2.1 添加传输地址对象</span></span><br><span class="line">    transportClient.addTransportAddress(<span class="keyword">new</span> TransportAddress(</span><br><span class="line">        InetAddress.getByName(<span class="string">"127.0.0.1"</span>), <span class="number">9300</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 创建实体对象</span></span><br><span class="line">    Article article = <span class="keyword">new</span> Article();</span><br><span class="line">    article.setId(<span class="number">3</span>);</span><br><span class="line">    article.setTitle(<span class="string">"lucene全文检索框架"</span>);</span><br><span class="line">    article.setContent(<span class="string">"lucene是apache组织开源的全文检索框架。"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 把article转化成json字符串</span></span><br><span class="line">    String jsonStr = <span class="keyword">new</span> ObjectMapper().writeValueAsString(article);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 添加文档</span></span><br><span class="line">    transportClient.prepareIndex(<span class="string">"blog1"</span>,<span class="string">"article"</span>, <span class="string">"3"</span>)</span><br><span class="line">        .setSource(jsonStr, XContentType.JSON).get();</span><br><span class="line">    <span class="comment">// 6. 释放资源</span></span><br><span class="line">    transportClient.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-4-小结"><a href="#7-4-小结" class="headerlink" title="7.4 小结"></a>7.4 小结</h4><ul><li>第一种方式: XContentBuilder封装文档数据</li><li>第二种方式: Map集合封装文档数据</li><li>第三种方式: pojo实体类封装文档数据</li></ul><h2 id="08、ElasticSearch：批量添加文档"><a href="#08、ElasticSearch：批量添加文档" class="headerlink" title="08、ElasticSearch：批量添加文档"></a>08、ElasticSearch：批量添加文档</h2><blockquote><p>目标: 掌握文档批量增加的代码实现</p></blockquote><h4 id="编程步骤-1"><a href="#编程步骤-1" class="headerlink" title="编程步骤"></a>编程步骤</h4><ul><li>创建Settings配置信息对象</li><li>创建ES传输客户端对象</li><li>创建批量请求构建对象</li><li>批量请求构建对象 循环添加 索引请求对象</li><li>批量请求构建对象提交请求</li><li>释放资源</li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 批量添加文档 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建Settings配置信息对象</span></span><br><span class="line">    Settings settings = Settings.builder()</span><br><span class="line">        .put(<span class="string">"cluster.name"</span>, <span class="string">"elasticsearch"</span>).build();</span><br><span class="line">    <span class="comment">// 2. 创建ES传输客户端对象</span></span><br><span class="line">    TransportClient transportClient = <span class="keyword">new</span> PreBuiltTransportClient(settings);</span><br><span class="line">    <span class="comment">// 2.1 添加传输地址对象</span></span><br><span class="line">    transportClient.addTransportAddress(<span class="keyword">new</span> TransportAddress(</span><br><span class="line">        InetAddress.getByName(<span class="string">"127.0.0.1"</span>), <span class="number">9300</span>));</span><br><span class="line">    <span class="comment">// 3. 创建批量请求构建对象</span></span><br><span class="line">    BulkRequestBuilder bulkRequestBuilder = transportClient.prepareBulk();</span><br><span class="line">    <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 4. 循环创建文档，添加索引请求对象</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i++)&#123;</span><br><span class="line">        Article article = <span class="keyword">new</span> Article();</span><br><span class="line">        article.setId(i);</span><br><span class="line">        article.setTitle(<span class="string">"dubbo分布式服务框架"</span> + i);</span><br><span class="line">        article.setContent(<span class="string">"dubbo阿里巴巴开源的高性能的RPC框架"</span> + i);</span><br><span class="line">        <span class="comment">// 4.1 创建索引请求对象</span></span><br><span class="line">        IndexRequest indexRequest = <span class="keyword">new</span> IndexRequest(<span class="string">"blog1"</span>,<span class="string">"article"</span>, i + <span class="string">""</span>)</span><br><span class="line">            .source(<span class="keyword">new</span> ObjectMapper().writeValueAsString(article),</span><br><span class="line">                    XContentType.JSON);</span><br><span class="line">        <span class="comment">// 4.2 添加索引请求对象</span></span><br><span class="line">        bulkRequestBuilder.add(indexRequest);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 提交请求</span></span><br><span class="line">    bulkRequestBuilder.get();</span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">"毫秒数："</span> + (end - begin));</span><br><span class="line">    <span class="comment">// 6. 释放资源</span></span><br><span class="line">    transportClient.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="09、ElasticSearch：修改文档"><a href="#09、ElasticSearch：修改文档" class="headerlink" title="09、ElasticSearch：修改文档"></a>09、ElasticSearch：修改文档</h2><blockquote><p>目标: 掌握文档修改的代码实现</p></blockquote><h4 id="编程步骤-2"><a href="#编程步骤-2" class="headerlink" title="编程步骤"></a>编程步骤</h4><ul><li>创建Settings配置信息对象</li><li>创建ES传输客户端对象</li><li>创建pojo对象，封装文档数据</li><li>把实体对象转化成json字符串</li><li>传输客户端对象修改文档到索引库</li><li>释放资源</li></ul><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 修改文档 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建Settings配置信息对象</span></span><br><span class="line">    Settings settings = Settings.builder()</span><br><span class="line">        .put(<span class="string">"cluster.name"</span>, <span class="string">"elasticsearch"</span>).build();</span><br><span class="line">    <span class="comment">// 2. 创建ES传输客户端对象</span></span><br><span class="line">    TransportClient transportClient = <span class="keyword">new</span> PreBuiltTransportClient(settings);</span><br><span class="line">    <span class="comment">// 2.1 添加传输地址对象</span></span><br><span class="line">    transportClient.addTransportAddress(<span class="keyword">new</span> TransportAddress(</span><br><span class="line">        InetAddress.getByName(<span class="string">"127.0.0.1"</span>), <span class="number">9300</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 创建实体对象</span></span><br><span class="line">    Article article = <span class="keyword">new</span> Article();</span><br><span class="line">    article.setId(<span class="number">1</span>);</span><br><span class="line">    article.setTitle(<span class="string">"lucene全文检索框架"</span>);</span><br><span class="line">    article.setContent(<span class="string">"lucene是apache组织开源的全文检索框架。"</span>);</span><br><span class="line">    <span class="comment">// 4. 把article转化成json字符串</span></span><br><span class="line">    String jsonStr = <span class="keyword">new</span> ObjectMapper().writeValueAsString(article);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 修改文档</span></span><br><span class="line">    transportClient.prepareUpdate(<span class="string">"blog1"</span>,<span class="string">"article"</span>, <span class="string">"1"</span>)</span><br><span class="line">        .setDoc(jsonStr, XContentType.JSON).get();</span><br><span class="line">    <span class="comment">// 6. 释放资源</span></span><br><span class="line">    transportClient.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意: 修改的时候，如果不存在这个id，会报错(id改成了10000)</p><p><img src="/2020/02/16/Elasticsearch/1573487830588.png" alt="1573487830588">   </p><h2 id="10、ElasticSearch：删除文档"><a href="#10、ElasticSearch：删除文档" class="headerlink" title="10、ElasticSearch：删除文档"></a>10、ElasticSearch：删除文档</h2><blockquote><p>目标: 掌握文档删除的代码实现</p></blockquote><h4 id="编程步骤-3"><a href="#编程步骤-3" class="headerlink" title="编程步骤"></a>编程步骤</h4><ul><li>创建Settings配置信息对象</li><li>创建ES传输客户端对象</li><li>传输客户端对象删除文档</li><li>释放资源</li></ul><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 删除文档 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建Settings配置信息对象</span></span><br><span class="line">    Settings settings = Settings.builder()</span><br><span class="line">        .put(<span class="string">"cluster.name"</span>, <span class="string">"elasticsearch"</span>).build();</span><br><span class="line">    <span class="comment">// 2. 创建ES传输客户端对象</span></span><br><span class="line">    TransportClient transportClient = <span class="keyword">new</span> PreBuiltTransportClient(settings);</span><br><span class="line">    <span class="comment">// 2.1 添加传输地址对象</span></span><br><span class="line">    transportClient.addTransportAddress(<span class="keyword">new</span> TransportAddress(</span><br><span class="line">        InetAddress.getByName(<span class="string">"127.0.0.1"</span>), <span class="number">9300</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 删除文档</span></span><br><span class="line">    transportClient.prepareDelete(<span class="string">"blog1"</span>, <span class="string">"article"</span>, <span class="string">"1"</span>).get();</span><br><span class="line">    <span class="comment">// 4. 释放资源</span></span><br><span class="line">    transportClient.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11、ElasticSearch：删除索引库"><a href="#11、ElasticSearch：删除索引库" class="headerlink" title="11、ElasticSearch：删除索引库"></a>11、ElasticSearch：删除索引库</h2><blockquote><p>目标: 掌握删除索引库的实现</p></blockquote><h4 id="第一种方式"><a href="#第一种方式" class="headerlink" title="第一种方式"></a>第一种方式</h4><p><img src="/2020/02/16/Elasticsearch/1573488203069.png" alt="1573488203069"> </p><h4 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式"></a>第二种方式</h4><ul><li><p>操作步骤</p><ul><li>创建Settings配置信息对象</li><li>创建ES传输客户端对象</li><li>索引库管理客户端删除索引库</li><li>释放资源</li></ul></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 删除索引库 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建Settings配置信息对象</span></span><br><span class="line">    Settings settings = Settings.builder()</span><br><span class="line">        .put(<span class="string">"cluster.name"</span>, <span class="string">"elasticsearch"</span>).build();</span><br><span class="line">    <span class="comment">// 2. 创建ES传输客户端对象</span></span><br><span class="line">    TransportClient transportClient = <span class="keyword">new</span> PreBuiltTransportClient(settings);</span><br><span class="line">    <span class="comment">// 2.1 添加传输地址对象</span></span><br><span class="line">    transportClient.addTransportAddress(<span class="keyword">new</span> TransportAddress(</span><br><span class="line">        InetAddress.getByName(<span class="string">"127.0.0.1"</span>), <span class="number">9300</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 删除索引库</span></span><br><span class="line">    transportClient.admin().indices().prepareDelete(<span class="string">"blog1"</span>).get();</span><br><span class="line">    <span class="comment">// 4. 释放资源</span></span><br><span class="line">    transportClient.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="12、ElasticSearch：IK中文分词器"><a href="#12、ElasticSearch：IK中文分词器" class="headerlink" title="12、ElasticSearch：IK中文分词器"></a>12、ElasticSearch：IK中文分词器</h2><blockquote><p>目标: 熟悉 ElasticSearch IK分词器集成</p></blockquote><p>ElasticSearch的<strong>默认分词器是单字分词器</strong>，当我们创建索引时，没有特定的进行映射的创建，所以会使用默认的分词器进行分词，即每个字单独分成一个词。 例如：我是程序员 分词后的效果为：我、是、程、序、员 而我们需要的分词效果是：我、是、程序、程序员 这样的话就需要对中文支持良好的分词器，支持中文分词的分词器有很多，word分词器、庖丁解牛、盘古分词、Ansj分词等，但我们常用的还是下面要介绍的<strong>IK分词器</strong>。</p><p><img src="/2020/02/16/Elasticsearch/1573521971232.png" alt="1573521971232"> </p><h4 id="12-1-IK分词器介绍"><a href="#12-1-IK分词器介绍" class="headerlink" title="12.1 IK分词器介绍"></a>12.1 IK分词器介绍</h4><ul><li>IKAnalyzer是一个开源的，基于java语言开发的轻量级的中文分词工具包。从2006年12月推出1.0版开始，IKAnalyzer已经推出 了3个大版本。最初，它是以开源项目Lucene为应用主体的，结合词典分词和文法分析算法的中文分词组件。新版本的IKAnalyzer3.0则发展为 面向Java的公用分词组件，独立于Lucene项目，同时提供了对Lucene的默认优化实现。</li><li>IK分词器3.0的特性如下:<ul><li>采用了特有的“正向迭代最细粒度切分算法“，具有60万字/秒的高速处理能力。</li><li>采用了多子处理器分析模式，支持：英文字母（IP地址、Email、URL）、数字（日期，常用中文数量词，罗马数字，科学计数法），中文词汇（姓名、地名处理）等分词处理。</li><li>对中英联合支持不是很好,在这方面的处理比较麻烦.需再做一次查询,同时是支持个人词条的优化的词典存储，更小的内存占用。</li><li>支持用户词典扩展定义。</li><li>针对Lucene全文检索优化的查询分析器IKQueryParser；采用歧义分析算法优化查询关键字的搜索排列组合，能极大的提高Lucene检索的命中率。</li></ul></li></ul><h4 id="12-2-IK分词器集成"><a href="#12-2-IK分词器集成" class="headerlink" title="12.2 IK分词器集成"></a>12.2 IK分词器集成</h4><ul><li><p>第一步: 下载地址：<a href="https://github.com/medcl/elasticsearch-analysis-ik/releases" target="_blank" rel="noopener">https://github.com/medcl/elasticsearch-analysis-ik/releases</a> 课程资料也提供了IK分词器的压缩包：</p><p><img src="/2020/02/16/Elasticsearch/1573522114892.png" alt="1573522114892"> </p></li><li><p>第二步: 解压，将解压后的elasticsearch文件夹拷贝到elasticsearch-6.6.2\plugins下，并重命名文件夹为ik</p><p><img src="/2020/02/16/Elasticsearch/1573522345001.png" alt="1573522345001"> </p></li><li><p>第三步: 重新启动ES服务器，即可加载IK分词器</p><p><img src="/2020/02/16/Elasticsearch/1573522383705.png" alt="1573522383705">  </p></li></ul><h4 id="12-3-IK分词器测试"><a href="#12-3-IK分词器测试" class="headerlink" title="12.3 IK分词器测试"></a>12.3 IK分词器测试</h4><ul><li><p>IK提供了两个分词算法<strong>ik_smart</strong> 和 <strong>ik_max_word</strong> 其中 ik_smart 为最少切分，ik_max_word为最细粒度切分。</p><ul><li><p>最小切分</p><p>请求地址：<a href="http://127.0.0.1:9200/_analyze?analyzer=ik_smart" target="_blank" rel="noopener">http://127.0.0.1:9200/_analyze</a></p><p>请求参数：{“analyzer” : “<strong>ik_smart</strong>“, “text” : “中国程序员”}</p><p><img src="/2020/02/16/Elasticsearch/1573522583719.png" alt="1573522583719"> </p></li><li><p>最细粒度切分</p><p>请求地址：<a href="http://127.0.0.1:9200/_analyze?analyzer=ik_smart" target="_blank" rel="noopener">http://127.0.0.1:9200/_analyze</a></p><p>请求参数：{“analyzer” : “<strong>ik_max_word</strong>“, “text” : “中国程序员”}</p><p><img src="/2020/02/16/Elasticsearch/1573522603197.png" alt="1573522603197"> </p></li></ul></li></ul><h2 id="13、ElasticSearch：创建映射"><a href="#13、ElasticSearch：创建映射" class="headerlink" title="13、ElasticSearch：创建映射"></a>13、ElasticSearch：创建映射</h2><blockquote><p>目标: 掌握 创建映射 的代码实现</p></blockquote><p>Mapping就是定义Document中的每个Field的特征（数据类型，是否存储，是否索引，是否分词等）</p><ul><li>类型名称: 就是前面讲的type的概念，类似于数据库中的表。</li><li>字段名: 任意填写，可以指定许多属性，例如<ul><li>type：类型，可以是text、long、short、date、integer、object等</li><li>index：是否索引，默认为true</li><li>store：是否存储，默认为false</li><li>analyzer：分词器，这里的ik_max_word即使用ik分词器</li></ul></li></ul><h4 id="编程步骤-4"><a href="#编程步骤-4" class="headerlink" title="编程步骤"></a>编程步骤</h4><ul><li>创建Settings配置信息对象</li><li>创建ES传输客户端对象</li><li>创建索引库管理客户端，创建空的索引库</li><li>创建映射信息json格式字符串，使用XContentBuilder</li><li>创建映射请求对象，封装请求信息</li><li>索引库管理客户端，为索引库添加映射</li><li>释放资源</li></ul><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 创建索引库映射 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test9</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建Settings配置信息对象</span></span><br><span class="line">    Settings settings = Settings.builder()</span><br><span class="line">        .put(<span class="string">"cluster.name"</span>, <span class="string">"elasticsearch"</span>).build();</span><br><span class="line">    <span class="comment">// 2. 创建ES传输客户端</span></span><br><span class="line">    TransportClient transportClient = <span class="keyword">new</span> PreBuiltTransportClient(settings);</span><br><span class="line">    <span class="comment">// 2.1 添加传输地址对象</span></span><br><span class="line">    transportClient.addTransportAddress(<span class="keyword">new</span> TransportAddress(</span><br><span class="line">        InetAddress.getByName(<span class="string">"127.0.0.1"</span>),<span class="number">9300</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 创建索引库管理客户端</span></span><br><span class="line">    IndicesAdminClient indices = transportClient.admin().indices();</span><br><span class="line">    <span class="comment">// 3.1 创建空的索引库</span></span><br><span class="line">    indices.prepareCreate(<span class="string">"blog2"</span>).get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 创建映射信息json格式字符串，使用XContentBuilder</span></span><br><span class="line">    XContentBuilder builder = XContentFactory.jsonBuilder();</span><br><span class="line">    builder.startObject()</span><br><span class="line">        .startObject(<span class="string">"article"</span>)</span><br><span class="line">        .startObject(<span class="string">"properties"</span>);</span><br><span class="line"></span><br><span class="line">    builder.startObject(<span class="string">"id"</span>)</span><br><span class="line">        .field(<span class="string">"type"</span>, <span class="string">"long"</span>)</span><br><span class="line">        .field(<span class="string">"store"</span>, <span class="keyword">true</span>)</span><br><span class="line">        .endObject();</span><br><span class="line"></span><br><span class="line">    builder.startObject(<span class="string">"title"</span>)</span><br><span class="line">        .field(<span class="string">"type"</span>, <span class="string">"text"</span>)</span><br><span class="line">        .field(<span class="string">"store"</span>, <span class="keyword">true</span>)</span><br><span class="line">        .field(<span class="string">"analyzer"</span>, <span class="string">"ik_smart"</span>)</span><br><span class="line">        .endObject();</span><br><span class="line"></span><br><span class="line">    builder.startObject(<span class="string">"content"</span>)</span><br><span class="line">        .field(<span class="string">"type"</span>, <span class="string">"text"</span>)</span><br><span class="line">        .field(<span class="string">"store"</span>, <span class="keyword">true</span>)</span><br><span class="line">        .field(<span class="string">"analyzer"</span>,<span class="string">"ik_smart"</span>)</span><br><span class="line">        .endObject();</span><br><span class="line"></span><br><span class="line">    builder.endObject();</span><br><span class="line">    builder.endObject();</span><br><span class="line">    builder.endObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 创建映射请求对象，封装请求信息</span></span><br><span class="line">    PutMappingRequest mappingRequest = <span class="keyword">new</span> PutMappingRequest(<span class="string">"blog2"</span>)</span><br><span class="line">        .type(<span class="string">"article"</span>).source(builder);</span><br><span class="line">    <span class="comment">// 6. 索引库管理客户端，为索引库添加映射</span></span><br><span class="line">    indices.putMapping(mappingRequest).get();</span><br><span class="line">    <span class="comment">// 7. 释放资源</span></span><br><span class="line">    transportClient.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/16/Elasticsearch/1573525882047.png" alt="1573525882047">  </p><p><img src="/2020/02/16/Elasticsearch/1573523917877.png" alt="1573523917877"> </p><p><strong>小结</strong></p><ul><li>映射不可以覆盖, 一定是建完索引库马上去做。</li><li>创建映射，如果索引库不存在的会报错。因为它没有自动创建索引库的功能。</li></ul><h2 id="14、ElasticSearch查询：匹配全部查询"><a href="#14、ElasticSearch查询：匹配全部查询" class="headerlink" title="14、ElasticSearch查询：匹配全部查询"></a>14、ElasticSearch查询：匹配全部查询</h2><blockquote><p>目标: 掌握 匹配全部查询 的代码实现</p></blockquote><p>先运行以前添加文档的三个测试方法(修改索引库名称为blog2)。</p><p><img src="/2020/02/16/Elasticsearch/1573526457688.png" alt="1573526457688">  </p><h4 id="编程步骤-5"><a href="#编程步骤-5" class="headerlink" title="编程步骤"></a>编程步骤</h4><ul><li><p>创建Settings配置信息对象</p></li><li><p>创建ES传输客户端对象</p></li><li><p>创建搜索请求构建对象(封装查询条件)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置查询条件(匹配全部)</span></span><br><span class="line">searchRequestBuilder.setQuery(QueryBuilders.matchAllQuery());</span><br></pre></td></tr></table></figure></li><li><p>执行请求,得到搜索响应对象</p></li><li><p>获取搜索结果</p></li><li><p>迭代搜索结果</p></li><li><p>释放资源</p></li></ul><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.elasticsearch.action.search.SearchRequestBuilder;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.action.search.SearchResponse;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.transport.TransportClient;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.common.settings.Settings;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.common.transport.TransportAddress;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.index.query.QueryBuilders;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.search.SearchHit;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.search.SearchHits;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.transport.client.PreBuiltTransportClient;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 匹配全部 */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建Settings配置信息对象</span></span><br><span class="line">        Settings settings = Settings.builder()</span><br><span class="line">                .put(<span class="string">"cluster.name"</span>,<span class="string">"elasticsearch"</span>).build();</span><br><span class="line">        <span class="comment">// 2. 创建ES传输客户端对象</span></span><br><span class="line">        TransportClient transportClient = <span class="keyword">new</span> PreBuiltTransportClient(Settings.EMPTY);</span><br><span class="line">        <span class="comment">// 2.1 添加传输地址对象</span></span><br><span class="line">        transportClient.addTransportAddress(<span class="keyword">new</span> TransportAddress(</span><br><span class="line">                InetAddress.getByName(<span class="string">"127.0.0.1"</span>), <span class="number">9300</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 创建搜索请求构建对象</span></span><br><span class="line">        SearchRequestBuilder searchRequestBuilder = transportClient</span><br><span class="line">                .prepareSearch(<span class="string">"blog2"</span>).setTypes(<span class="string">"article"</span>);</span><br><span class="line">        <span class="comment">// 3.1 设置查询条件 (匹配全部)</span></span><br><span class="line">        searchRequestBuilder.setQuery(QueryBuilders.matchAllQuery());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 执行请求，得到搜索响应对象</span></span><br><span class="line">        SearchResponse searchResponse = searchRequestBuilder.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 获取搜索结果</span></span><br><span class="line">        SearchHits hits = searchResponse.getHits();</span><br><span class="line">        System.out.println(<span class="string">"总命中数："</span> + hits.totalHits);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 迭代搜索结果</span></span><br><span class="line">        <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">            System.out.println(<span class="string">"JSON字符串："</span> + hit.getSourceAsString());</span><br><span class="line">            System.out.println(<span class="string">"id: "</span> + hit.getSourceAsMap().get(<span class="string">"id"</span>));</span><br><span class="line">            System.out.println(<span class="string">"title: "</span> + hit.getSourceAsMap().get(<span class="string">"title"</span>));</span><br><span class="line">            System.out.println(<span class="string">"content: "</span> + hit.getSourceAsMap().get(<span class="string">"content"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 7. 释放资源</span></span><br><span class="line">        transportClient.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="/2020/02/16/Elasticsearch/1573526308208.png" alt="1573526308208"> </p><h2 id="15、ElasticSearch查询：字符串查询"><a href="#15、ElasticSearch查询：字符串查询" class="headerlink" title="15、ElasticSearch查询：字符串查询"></a>15、ElasticSearch查询：字符串查询</h2><blockquote><p>目标: 掌握 字符串查询 的代码实现</p></blockquote><h4 id="编程步骤-6"><a href="#编程步骤-6" class="headerlink" title="编程步骤"></a>编程步骤</h4><ul><li><p>创建Settings配置信息对象</p></li><li><p>创建ES传输客户端对象</p></li><li><p>创建搜索请求构建对象(封装查询条件)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置查询条件(字符串查询)</span></span><br><span class="line">searchRequestBuilder.setQuery(QueryBuilders.queryStringQuery(<span class="string">"搜索服务"</span>));</span><br></pre></td></tr></table></figure></li><li><p>执行请求,得到搜索响应对象</p></li><li><p>获取搜索结果</p></li><li><p>迭代搜索结果</p></li><li><p>释放资源</p></li></ul><h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 字符串查询 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 创建Settings配置信息对象</span></span><br><span class="line">    Settings settings = Settings.builder()</span><br><span class="line">        .put(<span class="string">"cluster.name"</span>,<span class="string">"elasticsearch"</span>).build();</span><br><span class="line">    <span class="comment">// 2. 创建ES传输客户端对象</span></span><br><span class="line">    TransportClient transportClient = <span class="keyword">new</span> PreBuiltTransportClient(Settings.EMPTY);</span><br><span class="line">    <span class="comment">// 2.1 添加传输地址对象</span></span><br><span class="line">    transportClient.addTransportAddress(<span class="keyword">new</span> TransportAddress(</span><br><span class="line">        InetAddress.getByName(<span class="string">"127.0.0.1"</span>), <span class="number">9300</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 创建搜索请求构建对象</span></span><br><span class="line">    SearchRequestBuilder searchRequestBuilder = transportClient</span><br><span class="line">        .prepareSearch(<span class="string">"blog2"</span>).setTypes(<span class="string">"article"</span>);</span><br><span class="line">    <span class="comment">// 3.1 设置查询条件(字符串查询)</span></span><br><span class="line">    searchRequestBuilder.setQuery(QueryBuilders.queryStringQuery(<span class="string">"搜索服务"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 执行请求，得到搜索响应对象</span></span><br><span class="line">    SearchResponse searchResponse = searchRequestBuilder.get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 获取搜索结果</span></span><br><span class="line">    SearchHits hits = searchResponse.getHits();</span><br><span class="line">    System.out.println(<span class="string">"总命中数："</span> + hits.totalHits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 迭代搜索结果</span></span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        System.out.println(<span class="string">"JSON字符串："</span> + hit.getSourceAsString());</span><br><span class="line">        System.out.println(<span class="string">"id: "</span> + hit.getSourceAsMap().get(<span class="string">"id"</span>));</span><br><span class="line">        System.out.println(<span class="string">"title: "</span> + hit.getSourceAsMap().get(<span class="string">"title"</span>));</span><br><span class="line">        System.out.println(<span class="string">"content: "</span> + hit.getSourceAsMap().get(<span class="string">"content"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 7. 释放资源</span></span><br><span class="line">    transportClient.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="/2020/02/16/Elasticsearch/1573526909527.png" alt="1573526909527"> </p><h2 id="16、ElasticSearch查询：词条查询"><a href="#16、ElasticSearch查询：词条查询" class="headerlink" title="16、ElasticSearch查询：词条查询"></a>16、ElasticSearch查询：词条查询</h2><blockquote><p>目标: 掌握 词条查询 的代码实现</p></blockquote><h4 id="编程步骤-7"><a href="#编程步骤-7" class="headerlink" title="编程步骤"></a>编程步骤</h4><ul><li><p>创建Settings配置信息对象</p></li><li><p>创建ES传输客户端对象</p></li><li><p>创建搜索请求构建对象(封装查询条件)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置查询条件(词条查询)</span></span><br><span class="line">searchRequestBuilder.setQuery(QueryBuilders.termQuery(<span class="string">"title"</span>,<span class="string">"搜索服务"</span>));</span><br></pre></td></tr></table></figure></li><li><p>执行请求,得到搜索响应对象</p></li><li><p>获取搜索结果</p></li><li><p>迭代搜索结果</p></li><li><p>释放资源</p></li></ul><h4 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 词条查询(搜索条件不分词) */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 创建Settings配置信息对象</span></span><br><span class="line">    Settings settings = Settings.builder()</span><br><span class="line">        .put(<span class="string">"cluster.name"</span>,<span class="string">"elasticsearch"</span>).build();</span><br><span class="line">    <span class="comment">// 2. 创建ES传输客户端对象</span></span><br><span class="line">    TransportClient transportClient = <span class="keyword">new</span> PreBuiltTransportClient(Settings.EMPTY);</span><br><span class="line">    <span class="comment">// 2.1 添加传输地址对象</span></span><br><span class="line">    transportClient.addTransportAddress(<span class="keyword">new</span> TransportAddress(</span><br><span class="line">        InetAddress.getByName(<span class="string">"127.0.0.1"</span>), <span class="number">9300</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 创建搜索请求构建对象</span></span><br><span class="line">    SearchRequestBuilder searchRequestBuilder = transportClient</span><br><span class="line">        .prepareSearch(<span class="string">"blog2"</span>).setTypes(<span class="string">"article"</span>);</span><br><span class="line">    <span class="comment">// 3.1 设置查询条件(词条查询)</span></span><br><span class="line">    searchRequestBuilder.setQuery(QueryBuilders.termQuery(<span class="string">"title"</span>,<span class="string">"搜索服务"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 执行请求，得到搜索响应对象</span></span><br><span class="line">    SearchResponse searchResponse = searchRequestBuilder.get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 获取搜索结果</span></span><br><span class="line">    SearchHits hits = searchResponse.getHits();</span><br><span class="line">    System.out.println(<span class="string">"总命中数："</span> + hits.totalHits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 迭代搜索结果</span></span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        System.out.println(<span class="string">"JSON字符串："</span> + hit.getSourceAsString());</span><br><span class="line">        System.out.println(<span class="string">"id: "</span> + hit.getSourceAsMap().get(<span class="string">"id"</span>));</span><br><span class="line">        System.out.println(<span class="string">"title: "</span> + hit.getSourceAsMap().get(<span class="string">"title"</span>));</span><br><span class="line">        System.out.println(<span class="string">"content: "</span> + hit.getSourceAsMap().get(<span class="string">"content"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 7. 释放资源</span></span><br><span class="line">    transportClient.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="/2020/02/16/Elasticsearch/1573527275140.png" alt="1573527275140"> </p><blockquote><p>注意: 搜索条件不分词。</p></blockquote><h2 id="17、ElasticSearch查询：根据ID查询"><a href="#17、ElasticSearch查询：根据ID查询" class="headerlink" title="17、ElasticSearch查询：根据ID查询"></a>17、ElasticSearch查询：根据ID查询</h2><blockquote><p>目标: 掌握 根据多个id主键查询 的代码实现</p></blockquote><h4 id="编程步骤-8"><a href="#编程步骤-8" class="headerlink" title="编程步骤"></a>编程步骤</h4><ul><li><p>创建Settings配置信息对象</p></li><li><p>创建ES传输客户端对象</p></li><li><p>创建搜索请求构建对象(封装查询条件)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置查询条件(多个主键id)</span></span><br><span class="line">searchRequestBuilder.setQuery(QueryBuilders.idsQuery().addIds(<span class="string">"2"</span>,<span class="string">"3"</span>));</span><br></pre></td></tr></table></figure></li><li><p>执行请求,得到搜索响应对象</p></li><li><p>获取搜索结果</p></li><li><p>迭代搜索结果</p></li><li><p>释放资源</p></li></ul><h4 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 根据id主键查询*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 创建Settings配置信息对象</span></span><br><span class="line">    Settings settings = Settings.builder()</span><br><span class="line">        .put(<span class="string">"cluster.name"</span>,<span class="string">"elasticsearch"</span>).build();</span><br><span class="line">    <span class="comment">// 2. 创建ES传输客户端对象</span></span><br><span class="line">    TransportClient transportClient = <span class="keyword">new</span> PreBuiltTransportClient(Settings.EMPTY);</span><br><span class="line">    <span class="comment">// 2.1 添加传输地址对象</span></span><br><span class="line">    transportClient.addTransportAddress(<span class="keyword">new</span> TransportAddress(</span><br><span class="line">        InetAddress.getByName(<span class="string">"127.0.0.1"</span>), <span class="number">9300</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 创建搜索请求构建对象</span></span><br><span class="line">    SearchRequestBuilder searchRequestBuilder = transportClient</span><br><span class="line">        .prepareSearch(<span class="string">"blog2"</span>).setTypes(<span class="string">"article"</span>);</span><br><span class="line">    <span class="comment">// 3.1 设置查询条件(多个主键id)</span></span><br><span class="line">    searchRequestBuilder.setQuery(QueryBuilders.idsQuery().addIds(<span class="string">"2"</span>,<span class="string">"3"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 执行请求，得到搜索响应对象</span></span><br><span class="line">    SearchResponse searchResponse = searchRequestBuilder.get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 获取搜索结果</span></span><br><span class="line">    SearchHits hits = searchResponse.getHits();</span><br><span class="line">    System.out.println(<span class="string">"总命中数："</span> + hits.totalHits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 迭代搜索结果</span></span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        System.out.println(<span class="string">"JSON字符串："</span> + hit.getSourceAsString());</span><br><span class="line">        System.out.println(<span class="string">"id: "</span> + hit.getSourceAsMap().get(<span class="string">"id"</span>));</span><br><span class="line">        System.out.println(<span class="string">"title: "</span> + hit.getSourceAsMap().get(<span class="string">"title"</span>));</span><br><span class="line">        System.out.println(<span class="string">"content: "</span> + hit.getSourceAsMap().get(<span class="string">"content"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 7. 释放资源</span></span><br><span class="line">    transportClient.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="/2020/02/16/Elasticsearch/1573528234404.png" alt="1573528234404"> </p><h2 id="18、ElasticSearch查询：范围查询"><a href="#18、ElasticSearch查询：范围查询" class="headerlink" title="18、ElasticSearch查询：范围查询"></a>18、ElasticSearch查询：范围查询</h2><blockquote><p>目标: 掌握 范围查询 的代码实现</p></blockquote><h4 id="编程步骤-9"><a href="#编程步骤-9" class="headerlink" title="编程步骤"></a>编程步骤</h4><ul><li><p>创建Settings配置信息对象</p></li><li><p>创建ES传输客户端对象</p></li><li><p>创建搜索请求构建对象(封装查询条件)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置查询条件(范围查询)</span></span><br><span class="line"><span class="comment">// from("1", false): 开始(是否包含开始)</span></span><br><span class="line"><span class="comment">// to("3", false): 结束(是否包含结束)</span></span><br><span class="line">searchRequestBuilder.setQuery(QueryBuilders.rangeQuery(<span class="string">"id"</span>)</span><br><span class="line">                              .from(<span class="string">"1"</span>, <span class="keyword">false</span>)</span><br><span class="line">                              .to(<span class="string">"3"</span>, <span class="keyword">false</span>));</span><br></pre></td></tr></table></figure></li><li><p>执行请求,得到搜索响应对象</p></li><li><p>获取搜索结果</p></li><li><p>迭代搜索结果</p></li><li><p>释放资源</p></li></ul><h4 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 范围查询 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建Settings配置信息对象</span></span><br><span class="line">    Settings settings = Settings.builder()</span><br><span class="line">        .put(<span class="string">"cluster.name"</span>,<span class="string">"elasticsearch"</span>).build();</span><br><span class="line">    <span class="comment">// 2. 创建ES传输客户端对象</span></span><br><span class="line">    TransportClient transportClient = <span class="keyword">new</span> PreBuiltTransportClient(Settings.EMPTY);</span><br><span class="line">    <span class="comment">// 2.1 添加传输地址对象</span></span><br><span class="line">    transportClient.addTransportAddress(<span class="keyword">new</span> TransportAddress(</span><br><span class="line">        InetAddress.getByName(<span class="string">"127.0.0.1"</span>), <span class="number">9300</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 创建搜索请求构建对象</span></span><br><span class="line">    SearchRequestBuilder searchRequestBuilder = transportClient</span><br><span class="line">        .prepareSearch(<span class="string">"blog2"</span>).setTypes(<span class="string">"article"</span>);</span><br><span class="line">    <span class="comment">// 3.1 设置查询条件(范围查询)</span></span><br><span class="line">    <span class="comment">// from("1", false): 开始(是否包含开始)</span></span><br><span class="line">    <span class="comment">// to("3", false): 结束(是否包含结束)</span></span><br><span class="line">    searchRequestBuilder.setQuery(QueryBuilders.rangeQuery(<span class="string">"id"</span>)</span><br><span class="line">                                  .from(<span class="string">"1"</span>, <span class="keyword">false</span>).to(<span class="string">"3"</span>, <span class="keyword">false</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 执行请求，得到搜索响应对象</span></span><br><span class="line">    SearchResponse searchResponse = searchRequestBuilder.get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 获取搜索结果</span></span><br><span class="line">    SearchHits hits = searchResponse.getHits();</span><br><span class="line">    System.out.println(<span class="string">"总命中数："</span> + hits.totalHits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 迭代搜索结果</span></span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        System.out.println(<span class="string">"JSON字符串："</span> + hit.getSourceAsString());</span><br><span class="line">        System.out.println(<span class="string">"id: "</span> + hit.getSourceAsMap().get(<span class="string">"id"</span>));</span><br><span class="line">        System.out.println(<span class="string">"title: "</span> + hit.getSourceAsMap().get(<span class="string">"title"</span>));</span><br><span class="line">        System.out.println(<span class="string">"content: "</span> + hit.getSourceAsMap().get(<span class="string">"content"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 7. 释放资源</span></span><br><span class="line">    transportClient.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="/2020/02/16/Elasticsearch/1573528844880.png" alt="1573528844880"> </p><h2 id="19、ElasticSearch查询：分页和排序"><a href="#19、ElasticSearch查询：分页和排序" class="headerlink" title="19、ElasticSearch查询：分页和排序"></a>19、ElasticSearch查询：分页和排序</h2><blockquote><p>目标: 掌握 分页排序查询 的代码实现</p></blockquote><h4 id="编程步骤-10"><a href="#编程步骤-10" class="headerlink" title="编程步骤"></a>编程步骤</h4><ul><li><p>创建Settings配置信息对象</p></li><li><p>创建ES传输客户端对象</p></li><li><p>创建搜索请求构建对象(封装查询条件、分页、排序)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置查询条件(匹配查询)</span></span><br><span class="line">searchRequestBuilder.setQuery(QueryBuilders.matchQuery(<span class="string">"title"</span>,<span class="string">"服务框架"</span>));</span><br><span class="line"><span class="comment">// 设置分页起始数 (当前页码 - 1) * 页大小</span></span><br><span class="line">searchRequestBuilder.setFrom(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 设置页大小</span></span><br><span class="line">searchRequestBuilder.setSize(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 设置根据id排序(升序)</span></span><br><span class="line">searchRequestBuilder.addSort(<span class="string">"id"</span>, SortOrder.ASC);</span><br></pre></td></tr></table></figure></li><li><p>执行请求,得到搜索响应对象</p></li><li><p>获取搜索结果</p></li><li><p>迭代搜索结果</p></li><li><p>释放资源</p></li></ul><h4 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 搜索分页、排序 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 创建Settings配置信息对象</span></span><br><span class="line">    Settings settings = Settings.builder()</span><br><span class="line">        .put(<span class="string">"cluster.name"</span>,<span class="string">"elasticsearch"</span>).build();</span><br><span class="line">    <span class="comment">// 2. 创建ES传输客户端对象</span></span><br><span class="line">    TransportClient transportClient = <span class="keyword">new</span> PreBuiltTransportClient(settings);</span><br><span class="line">    <span class="comment">// 2.1 添加传输地址对象</span></span><br><span class="line">    transportClient.addTransportAddress(<span class="keyword">new</span> TransportAddress(</span><br><span class="line">        InetAddress.getByName(<span class="string">"127.0.0.1"</span>), <span class="number">9300</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 创建搜索请求构建对象</span></span><br><span class="line">    SearchRequestBuilder searchRequestBuilder = transportClient</span><br><span class="line">        .prepareSearch(<span class="string">"blog2"</span>).setTypes(<span class="string">"article"</span>);</span><br><span class="line">    <span class="comment">// 3.1 设置查询条件(匹配查询)</span></span><br><span class="line">    searchRequestBuilder.setQuery(QueryBuilders.matchQuery(<span class="string">"title"</span>,<span class="string">"服务框架"</span>));</span><br><span class="line">    <span class="comment">// 3.2 设置分页起始数 (当前页码 - 1) * 页大小</span></span><br><span class="line">    searchRequestBuilder.setFrom(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 3.3 设置页大小</span></span><br><span class="line">    searchRequestBuilder.setSize(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 3.4 设置根据id排序(升序)</span></span><br><span class="line">    searchRequestBuilder.addSort(<span class="string">"id"</span>, SortOrder.ASC);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 执行请求，得到搜索响应对象</span></span><br><span class="line">    SearchResponse searchResponse = searchRequestBuilder.get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 获取搜索结果</span></span><br><span class="line">    SearchHits hits = searchResponse.getHits();</span><br><span class="line">    System.out.println(<span class="string">"总命中数："</span> + hits.totalHits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 迭代搜索结果</span></span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        System.out.println(<span class="string">"JSON字符串："</span> + hit.getSourceAsString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 7. 释放资源</span></span><br><span class="line">    transportClient.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果:</p><p><img src="/2020/02/16/Elasticsearch/1573529973243.png" alt="1573529973243"> </p><h2 id="20、ElasticSearch查询：高亮显示"><a href="#20、ElasticSearch查询：高亮显示" class="headerlink" title="20、ElasticSearch查询：高亮显示"></a>20、ElasticSearch查询：高亮显示</h2><blockquote><p>目标: 掌握 文档高亮显示 的代码实现</p></blockquote><h4 id="20-1-什么是高亮显示"><a href="#20-1-什么是高亮显示" class="headerlink" title="20.1 什么是高亮显示"></a>20.1 什么是高亮显示</h4><ul><li><p>根据关键字搜索时，搜索出的内容中的关键字会显示不同的颜色，称之为高亮百度搜索关键字”elasticsearch”</p><p><img src="/2020/02/16/Elasticsearch/1573531763857.png" alt="1573531763857"> </p></li><li><p>京东商城搜索“iphone xs max”</p><p><img src="/2020/02/16/Elasticsearch/1573531786291.png" alt="1573531786291"> </p></li></ul><h4 id="20-2-高亮显示html分析"><a href="#20-2-高亮显示html分析" class="headerlink" title="20.2 高亮显示html分析"></a>20.2 高亮显示html分析</h4><ul><li><p>通过开发者工具查看高亮数据的html代码实现:</p><p><img src="/2020/02/16/Elasticsearch/1573531831288.png" alt="1573531831288"> </p><p>说明: ElasticSearch可以对查询出的内容中关键字部分进行标签和样式的设置，但是你需要告诉ElasticSearch使用什么标签对高亮关键字进行包裹。</p></li></ul><h4 id="20-3-高亮显示实现"><a href="#20-3-高亮显示实现" class="headerlink" title="20.3 高亮显示实现"></a>20.3 高亮显示实现</h4><p><strong>编程步骤</strong></p><ul><li><p>创建Settings配置信息对象</p></li><li><p>创建ES传输客户端对象</p></li><li><p>创建搜索请求构建对象(封装查询条件、设置高亮对象)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置查询条件</span></span><br><span class="line">searchRequestBuilder.setQuery(QueryBuilders.termQuery(<span class="string">"content"</span>,<span class="string">"开源"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建高亮构建对象</span></span><br><span class="line">HighlightBuilder highlightBuilder = <span class="keyword">new</span> HighlightBuilder();</span><br><span class="line"><span class="comment">// 设置高亮字段</span></span><br><span class="line">highlightBuilder.field(<span class="string">"content"</span>);</span><br><span class="line"><span class="comment">// 设置高亮格式器前缀</span></span><br><span class="line">highlightBuilder.preTags(<span class="string">"&lt;font color='red'&gt;"</span>);</span><br><span class="line"><span class="comment">// 设置高亮格式器后缀</span></span><br><span class="line">highlightBuilder.postTags(<span class="string">"&lt;/font&gt;"</span>);</span><br><span class="line"><span class="comment">// 设置高亮对象</span></span><br><span class="line">searchRequestBuilder.highlighter(highlightBuilder);</span><br></pre></td></tr></table></figure></li><li><p>执行请求,得到搜索响应对象</p></li><li><p>获取搜索结果</p></li><li><p>迭代搜索结果(获取高亮内容)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取高亮字段集合</span></span><br><span class="line">Map&lt;String, HighlightField&gt; highlightFields = hit.getHighlightFields();</span><br><span class="line"><span class="comment">// 获取content字段的高亮内容</span></span><br><span class="line">String content = highlightFields.get(<span class="string">"content"</span>).getFragments()[<span class="number">0</span>].toString();</span><br></pre></td></tr></table></figure></li><li><p>释放资源</p></li></ul><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 高亮显示 */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建Settings配置信息对象</span></span><br><span class="line">    Settings settings = Settings.builder()</span><br><span class="line">        .put(<span class="string">"cluster.name"</span>,<span class="string">"elasticsearch"</span>).build();</span><br><span class="line">    <span class="comment">// 2. 创建ES传输客户端对象</span></span><br><span class="line">    TransportClient transportClient = <span class="keyword">new</span> PreBuiltTransportClient(settings);</span><br><span class="line">    <span class="comment">// 2.1 添加传输地址对象</span></span><br><span class="line">    transportClient.addTransportAddress(<span class="keyword">new</span> TransportAddress(</span><br><span class="line">        InetAddress.getByName(<span class="string">"127.0.0.1"</span>), <span class="number">9300</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 创建搜索请求构建对象</span></span><br><span class="line">    SearchRequestBuilder searchRequestBuilder = transportClient</span><br><span class="line">        .prepareSearch(<span class="string">"blog2"</span>).setTypes(<span class="string">"article"</span>);</span><br><span class="line">    <span class="comment">// 3.1 设置查询条件</span></span><br><span class="line">    searchRequestBuilder.setQuery(QueryBuilders.termQuery(<span class="string">"content"</span>,<span class="string">"开源"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.2 创建高亮构建对象</span></span><br><span class="line">    HighlightBuilder highlightBuilder = <span class="keyword">new</span> HighlightBuilder();</span><br><span class="line">    <span class="comment">// 3.2.1 设置高亮字段</span></span><br><span class="line">    highlightBuilder.field(<span class="string">"content"</span>);</span><br><span class="line">    <span class="comment">// 3.2.2 设置高亮格式器前缀</span></span><br><span class="line">    highlightBuilder.preTags(<span class="string">"&lt;font color='red'&gt;"</span>);</span><br><span class="line">    <span class="comment">// 3.2.3 设置高亮格式器后缀</span></span><br><span class="line">    highlightBuilder.postTags(<span class="string">"&lt;/font&gt;"</span>);</span><br><span class="line">    <span class="comment">// 3.3 设置高亮对象</span></span><br><span class="line">    searchRequestBuilder.highlighter(highlightBuilder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 执行请求，得到搜索响应对象</span></span><br><span class="line">    SearchResponse searchResponse = searchRequestBuilder.get();</span><br><span class="line">    <span class="comment">// 5. 获取搜索结果</span></span><br><span class="line">    SearchHits hits = searchResponse.getHits();</span><br><span class="line">    System.out.println(<span class="string">"总命中数："</span> + hits.totalHits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 迭代搜索结果</span></span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        <span class="comment">// 获取高亮字段集合</span></span><br><span class="line">        Map&lt;String, HighlightField&gt; highlightFields = hit.getHighlightFields();</span><br><span class="line">        <span class="comment">// 获取content字段的高亮内容</span></span><br><span class="line">        String content = highlightFields.get(<span class="string">"content"</span>)</span><br><span class="line">                              .getFragments()[<span class="number">0</span>].toString();</span><br><span class="line">        System.out.println(hit.getSourceAsMap().get(<span class="string">"id"</span>) + <span class="string">"\t"</span></span><br><span class="line">                           + hit.getSourceAsMap().get(<span class="string">"title"</span>) + <span class="string">"\t"</span> + content);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 7. 释放资源</span></span><br><span class="line">    transportClient.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><p><img src="/2020/02/16/Elasticsearch/1573532677574.png" alt="1573532677574"> </p><h2 id="21、课程总结"><a href="#21、课程总结" class="headerlink" title="21、课程总结"></a>21、课程总结</h2><p> <strong>今天课程重点</strong></p><ul><li><p>Elasticsearch安装与启动</p></li><li><p>Elasticsearch创建索引库</p></li><li><p>Elasticsearch添加文档</p></li><li><p>Elasticsearch修改文档</p></li><li><p>Elasticsearch删除文档</p></li><li><p>Elasticsearch创建映射</p></li><li><p>Elasticsearch查询</p><p><img src="/2020/02/16/Elasticsearch/1573543487274.png" alt="1573543487274"> </p></li></ul><h2 id="拓展：ElasticSearch集群搭建"><a href="#拓展：ElasticSearch集群搭建" class="headerlink" title="== 拓展：ElasticSearch集群搭建 =="></a>== 拓展：ElasticSearch集群搭建 ==</h2><h3 id="集群介绍"><a href="#集群介绍" class="headerlink" title="集群介绍"></a>集群介绍</h3><ul><li>ES集群是一个P2P类型（使用gossip协议）的分布式系统，除了集群状态管理以外，其他所有的请求都可以发送到集群内任意一台节点上，这个节点可以自己找到需要转发给那些节点，并且直接跟这些节点通信。所以从网络架构及服务配置上来说，构建集群所需要的配置及其简单。在ES2.0之前，无阻碍的网络下，所有配置了相同<code>cluster.name</code>的节点都自动归属到一个集群中。2.0版本之后，基于安全的考虑避免开发环境过于随便造成的麻烦，从2.0版本开始，默认的自动默认的发现方式改为了广播（unicast）方式。配置里提供几台节点的地址。ES将其视作gossip router角色，借以完成集群的发现。由于这只是ES内一个很小的功能，索引gossip router角色并不需要单独配置，每个ES节点都可以担任，索引采用广播方式的集群，各节点都配置相同的几个节点列表作为router即可。</li><li>集群中节点数量没有限制，一般大于等于2个节点就可以看做是集群了。一般处于高性能及高可用方面来考虑一般集群中的节点数量都是3个及3个以上。</li></ul><h3 id="集群概念"><a href="#集群概念" class="headerlink" title="集群概念"></a>集群概念</h3><ul><li><p>集群 cluster</p><p>一个集群就是由一个或多个节点组织在一起，它们共同持有整个的数据，并一起提供索引和搜索功能。一个集群由一个唯一的名字标识，这个名字默认就是“elasticsearch”。这个名字是重要的，因为一个节点只能通过指定某个集群的名字，来加入这个集群</p></li><li><p>节点 node</p><p>一个节点是集群中的一个服务器，作为集群的一部分，它存储数据，参与集群的索引和搜索功能。和集群类似，一个节点也是由一个名字来标识的，默认情况下，这个名字是一个随机的漫威漫画角色的名字，这个名字会在启动的时候赋予节点。这个名字对于管理工作来说挺重要的，因为在这个管理过程中，你会去确定网络中的哪些服务器对应于Elasticsearch集群中的哪些节点。 一个节点可以通过配置集群名称的方式来加入一个指定的集群。默认情况下，每个节点都会被安排加入到一个叫 做“elasticsearch”的集群中，这意味着，如果你在你的网络中启动了若干个节点，并假定它们能够相互发现彼此， 它们将会自动地形成并加入到一个叫做“elasticsearch”的集群中。 在一个集群里，只要你想，可以拥有任意多个节点。而且，如果当前你的网络中没有运行任何Elasticsearch节点， 这时启动一个节点，会默认创建并加入一个叫做“elasticsearch”的集群。</p></li><li><p>分片和复制shards&amp;replicas</p><p>一个索引可以存储超出单个节点硬件限制的大量数据。比如，一个具有10亿文档的索引占据1TB的磁盘空间，而任一节点都没有这样大的磁盘空间；或者单个节点处理搜索请求，响应太慢。为了解决这个问题，Elasticsearch提供了将索引划分成多份的能力，这些份就叫做分片。当你创建一个索引的时候，你可以指定你想要的分片的数量。每个分片本身也是一个功能完善并且独立的“索引”，这个“索引”可以被放置到集群中的任何节点上。分片很重要，主要有两方面的原因：</p><ul><li>允许你水平分割/扩展你的内容容量。</li><li>允许你在分片（潜在地，位于多个节点上）之上进行分布式的、并行的操作，进而提高性能/吞吐量。至于一个分片怎样分布，它的文档怎样聚合回搜索请求，是完全由Elasticsearch管理的，对于作为用户的你来说，这些都是透明的。在一个网络/云的环境里，失败随时都可能发生，在某个分片/节点不知怎么的就处于离线状态，或者由于任何原因消失了，这种情况下，有一个故障转移机制是非常有用并且是强烈推荐的。为此目的，Elasticsearch允许你创建分片的一份或多份拷贝，这些拷贝叫做复制分片，或者直接叫复制。复制之所以重要，有两个主要原因： 在分片/节点失败的情况下，提供了高可用性。因为这个原因，注意到复制分片从不与原/主要（original/primary）分片置于同一节点上是非常重要的。扩展你的搜索量/吞吐量，因为搜索可以在所有的复制上并行运行。总之，每个索引可以被分成多个分片。一个索引也可以被复制0次（意思是没有复制）或多次。一旦复制了，每个索引就有了主分片（作为复制源的原来的分片）和复制分片（主分片的拷贝）之别。分片和复制的数量可以在索引创建的时候指定。在索引创建之后，你可以在任何时候动态地改变复制的数量，但是你事后不能改变分片的数量。默认情况下，Elasticsearch中的每个索引被分片5个主分片和1个复制，这意味着，如果你的集群中至少有两个节点，你的索引将会有5个主分片和另外5个复制分片（1个完全拷贝），这样的话每个索引总共就有10个分片。</li></ul></li></ul><h3 id="集群原理"><a href="#集群原理" class="headerlink" title="集群原理"></a>集群原理</h3><ul><li><p>我们面临的第一个问题就是数据量太大，单点存储量有限的问题。大家觉得应该如何解决？我们可以把数据拆分成多份，每一份存储到不同机器节点（node），从而实现减少每个节点数据量的目的。这就是数据的分布式存储，也叫做：数据分片（Shard）。</p><p><img src="/2020/02/16/Elasticsearch/1573541795932.png" alt="1573541795932"> </p></li><li><p>数据分片解决了海量数据存储的问题，但是如果出现单点故障，那么分片数据就不再完整，这又该如何解决呢？就像大家为了备份手机数据，会额外存储一份到移动硬盘一样。我们可以给每个分片数据进行备份，存储到其它节点，防止数据丢失，这就是数据备份，也叫数据副本（replica）。</p></li><li><p>数据备份可以保证高可用，但是每个分片备份一份，所需要的节点数量就会翻一倍，成本实在是太高了！</p></li><li><p>为了在高可用和成本间寻求平衡，我们可以这样做：首先对数据分片，存储到不同节点</p><p>然后对每个分片进行备份，放到对方节点，完成互相备份这样可以大大减少所需要的服务节点数量，如图，我们以3分片，每个分片备份一份为例：</p><p><img src="/2020/02/16/Elasticsearch/1573541887624.png" alt="1573541887624"> </p><p>在这个集群中，如果出现单节点故障，并不会导致数据缺失，所以保证了集群的高可用，同时也减少了节点中数据存储量。并且因为是多个节点存储数据，因此用户请求也会分发到不同服务器，并发能力也得到了一定的提升。</p></li></ul><h3 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h3><ul><li><p>复制es节点三份，并且删除<code>data</code>目录</p></li><li><p>修改三个节点上的信息，内容如下:</p><ul><li><p>三个节点端口号: http端口号(9201、9202、9203)  tcp端口号(9301、9302、9303)</p></li><li><p>第一个节点配置(elasticsearch.yml)</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 集群的名字，保证唯一，所有都必须一致 (17行)</span></span><br><span class="line"><span class="meta">cluster.name</span>: <span class="string">cluster-es</span></span><br><span class="line"><span class="comment"># 节点名称，必须不一样 (23行)</span></span><br><span class="line"><span class="meta">node.name</span>: <span class="string">node-1</span></span><br><span class="line"><span class="comment"># 必须为本机的ip地址 (55行)</span></span><br><span class="line"><span class="meta">network.host</span>: <span class="string">127.0.0.1</span></span><br><span class="line"><span class="comment"># 服务器断开，在同一机器下必须不一样 (59行)</span></span><br><span class="line"><span class="meta">http.port</span>: <span class="string">9201</span></span><br><span class="line"><span class="comment"># 集群间通讯端口号，在同一机器下必须不一样 (60行)</span></span><br><span class="line"><span class="meta">transport.tcp.port</span>: <span class="string">9301</span></span><br><span class="line"><span class="comment"># 设置集群自动发现机器ip:port集合，采用广播模式 (70行)</span></span><br><span class="line"><span class="meta">discovery.zen.ping.unicast.hosts</span>: <span class="string">["127.0.0.1:9301","127.0.0.1:9302","127.0.0.1:9303"]</span></span><br><span class="line"><span class="comment"># 防止脑裂。声明大于几个的投票主节点有效，请设置为（nodes / 2） + 1 (75行)</span></span><br><span class="line"><span class="meta">discovery.zen.minimum_master_nodes</span>: <span class="string">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许跨域 (92、93行)</span></span><br><span class="line"><span class="meta">http.cors.enabled</span>: <span class="string">true</span></span><br><span class="line"><span class="meta">http.cors.allow-origin</span>: <span class="string">"*"</span></span><br></pre></td></tr></table></figure></li><li><p>第二个节点配置(elasticsearch.yml)</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 集群的名字，保证唯一，所有都必须一致 (17行)</span></span><br><span class="line"><span class="meta">cluster.name</span>: <span class="string">cluster-es</span></span><br><span class="line"><span class="comment"># 节点名称，必须不一样 (23行  改)</span></span><br><span class="line"><span class="meta">node.name</span>: <span class="string">node-2</span></span><br><span class="line"><span class="comment"># 必须为本机的ip地址 (55行)</span></span><br><span class="line"><span class="meta">network.host</span>: <span class="string">127.0.0.1</span></span><br><span class="line"><span class="comment"># 服务器断开，在同一机器下必须不一样 (59行 改)</span></span><br><span class="line"><span class="meta">http.port</span>: <span class="string">9202</span></span><br><span class="line"><span class="comment"># 集群间通讯端口号，在同一机器下必须不一样 (60行 改)</span></span><br><span class="line"><span class="meta">transport.tcp.port</span>: <span class="string">9302</span></span><br><span class="line"><span class="comment"># 设置集群自动发现机器ip:port集合，采用广播模式 (70行)</span></span><br><span class="line"><span class="meta">discovery.zen.ping.unicast.hosts</span>: <span class="string">["127.0.0.1:9301","127.0.0.1:9302","127.0.0.1:9303"]</span></span><br><span class="line"><span class="comment"># 防止脑裂。声明大于几个的投票主节点有效，请设置为（nodes / 2） + 1 (75行)</span></span><br><span class="line"><span class="meta">discovery.zen.minimum_master_nodes</span>: <span class="string">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许跨域 (92、93行)</span></span><br><span class="line"><span class="meta">http.cors.enabled</span>: <span class="string">true</span></span><br><span class="line"><span class="meta">http.cors.allow-origin</span>: <span class="string">"*"</span></span><br></pre></td></tr></table></figure></li><li><p>第三个节点配置(elasticsearch.yml)</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 集群的名字，保证唯一，所有都必须一致 (17行)</span></span><br><span class="line"><span class="meta">cluster.name</span>: <span class="string">cluster-es</span></span><br><span class="line"><span class="comment"># 节点名称，必须不一样 (23行 改)</span></span><br><span class="line"><span class="meta">node.name</span>: <span class="string">node-3</span></span><br><span class="line"><span class="comment"># 必须为本机的ip地址 (55行)</span></span><br><span class="line"><span class="meta">network.host</span>: <span class="string">127.0.0.1</span></span><br><span class="line"><span class="comment"># 服务器断开，在同一机器下必须不一样 (59行 改)</span></span><br><span class="line"><span class="meta">http.port</span>: <span class="string">9203</span></span><br><span class="line"><span class="comment"># 集群间通讯端口号，在同一机器下必须不一样 (60行 改)</span></span><br><span class="line"><span class="meta">transport.tcp.port</span>: <span class="string">9303</span></span><br><span class="line"><span class="comment"># 设置集群自动发现机器ip:port集合，采用广播模式 (70行)</span></span><br><span class="line"><span class="meta">discovery.zen.ping.unicast.hosts</span>: <span class="string">["127.0.0.1:9301","127.0.0.1:9302","127.0.0.1:9303"]</span></span><br><span class="line"><span class="comment"># 防止脑裂。声明大于几个的投票主节点有效，请设置为（nodes / 2） + 1 (75行)</span></span><br><span class="line"><span class="meta">discovery.zen.minimum_master_nodes</span>: <span class="string">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许跨域 (92、93行)</span></span><br><span class="line"><span class="meta">http.cors.enabled</span>: <span class="string">true</span></span><br><span class="line"><span class="meta">http.cors.allow-origin</span>: <span class="string">"*"</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>分别启动三个es节点</p></li><li><p>通过es-header-master查看，连接任意一个节点都可以出现下面的效果，说明集群成功。</p><p><img src="/2020/02/16/Elasticsearch/1573534273127.png" alt="1573534273127">  </p></li></ul><h3 id="集群操作"><a href="#集群操作" class="headerlink" title="集群操作"></a>集群操作</h3><p><strong>编程步骤</strong></p><ul><li>创建Settings配置信息对象</li><li>创建ES传输客户端对象</li><li>使用传输客户端对象创建索引库</li><li>释放资源</li></ul><p><strong>核心代码</strong></p><ul><li><p>连接集群</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建Settings配置信息对象(主要配置集群名称)</span></span><br><span class="line"><span class="comment">// 参数一: 集群key (固定不变)</span></span><br><span class="line"><span class="comment">// 参数二：集群环境名称,默认的ES的环境集群名称为 "elasticsearch"</span></span><br><span class="line">Settings settings = Settings.builder()</span><br><span class="line">    .put(<span class="string">"cluster.name"</span>, <span class="string">"cluster-es"</span>).build();</span><br><span class="line"><span class="comment">// 2. 创建ES传输客户端对象</span></span><br><span class="line">TransportClient transportClient = <span class="keyword">new</span> PreBuiltTransportClient(settings);</span><br><span class="line"><span class="comment">// 2.1 添加传输地址对象(集群环境多个)</span></span><br><span class="line"><span class="comment">// 参数一：主机</span></span><br><span class="line"><span class="comment">// 参数二：端口</span></span><br><span class="line">transportClient.addTransportAddress(<span class="keyword">new</span></span><br><span class="line">        TransportAddress(InetAddress.getByName(<span class="string">"127.0.0.1"</span>), <span class="number">9301</span>));</span><br><span class="line">transportClient.addTransportAddress(<span class="keyword">new</span></span><br><span class="line">        TransportAddress(InetAddress.getByName(<span class="string">"127.0.0.1"</span>), <span class="number">9302</span>));</span><br><span class="line">transportClient.addTransportAddress(<span class="keyword">new</span></span><br><span class="line">        TransportAddress(InetAddress.getByName(<span class="string">"127.0.0.1"</span>), <span class="number">9303</span>));</span><br></pre></td></tr></table></figure></li><li><p>设置分片与副本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3. 创建索引库(index)</span></span><br><span class="line"><span class="comment">// 获取创建索引库请求构建对象</span></span><br><span class="line">CreateIndexRequestBuilder cirb = transportClient.admin().indices()</span><br><span class="line">    .prepareCreate(<span class="string">"blog1"</span>);</span><br><span class="line"><span class="comment">// 3.1 创建Map集合封装分片与副本设置信息</span></span><br><span class="line">Map&lt;String, Integer&gt; source = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line"><span class="comment">// 3.2 设置分片数量</span></span><br><span class="line">source.put(<span class="string">"number_of_shards"</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 3.3 设置副本数量</span></span><br><span class="line">source.put(<span class="string">"number_of_replicas"</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 3.4 设置map集合，执行请求</span></span><br><span class="line">cirb.setSettings(source).get();</span><br></pre></td></tr></table></figure><p><img src="/2020/02/16/Elasticsearch/1573542875065.png" alt="1573542875065"> </p></li></ul><p><strong>完整代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.elasticsearch.action.admin.indices.create.CreateIndexRequestBuilder;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.action.search.SearchRequestBuilder;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.action.search.SearchResponse;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.transport.TransportClient;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.common.settings.Settings;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.common.transport.TransportAddress;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.common.xcontent.XContentBuilder;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.common.xcontent.XContentFactory;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.index.query.QueryBuilders;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.search.SearchHit;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.search.SearchHits;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.transport.client.PreBuiltTransportClient;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 创建索引库(集群环境) */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建Settings配置信息对象(主要配置集群名称)</span></span><br><span class="line">        <span class="comment">// 参数一: 集群key (固定不变)</span></span><br><span class="line">        <span class="comment">// 参数二：集群环境名称,默认的ES的环境集群名称为 "elasticsearch"</span></span><br><span class="line">        Settings settings = Settings.builder()</span><br><span class="line">                .put(<span class="string">"cluster.name"</span>, <span class="string">"cluster-es"</span>).build();</span><br><span class="line">        <span class="comment">// 2. 创建ES传输客户端对象</span></span><br><span class="line">        TransportClient transportClient = <span class="keyword">new</span> PreBuiltTransportClient(settings);</span><br><span class="line">        <span class="comment">// 2.1 添加传输地址对象(集群环境多个)</span></span><br><span class="line">        <span class="comment">// 参数一：主机</span></span><br><span class="line">        <span class="comment">// 参数二：端口</span></span><br><span class="line">        transportClient.addTransportAddress(<span class="keyword">new</span></span><br><span class="line">                TransportAddress(InetAddress.getByName(<span class="string">"127.0.0.1"</span>), <span class="number">9301</span>));</span><br><span class="line">        transportClient.addTransportAddress(<span class="keyword">new</span></span><br><span class="line">                TransportAddress(InetAddress.getByName(<span class="string">"127.0.0.1"</span>), <span class="number">9302</span>));</span><br><span class="line">        transportClient.addTransportAddress(<span class="keyword">new</span></span><br><span class="line">                TransportAddress(InetAddress.getByName(<span class="string">"127.0.0.1"</span>), <span class="number">9303</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 创建索引库(index)</span></span><br><span class="line">        <span class="comment">// 获取创建索引库请求构建对象</span></span><br><span class="line">        CreateIndexRequestBuilder cirb = transportClient.admin().indices()</span><br><span class="line">                .prepareCreate(<span class="string">"blog1"</span>);</span><br><span class="line">        <span class="comment">// 3.1 创建Map集合封装分片与副本设置信息</span></span><br><span class="line">        Map&lt;String, Integer&gt; source = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">        <span class="comment">// 3.2 设置分片数量</span></span><br><span class="line">        source.put(<span class="string">"number_of_shards"</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 3.3 设置副本数量</span></span><br><span class="line">        source.put(<span class="string">"number_of_replicas"</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3.4 设置map集合，执行请求</span></span><br><span class="line">        cirb.setSettings(source).get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 释放资源</span></span><br><span class="line">        transportClient.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 添加文档 (集群环境) */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建Settings配置信息对象(主要配置集群名称)</span></span><br><span class="line">        Settings settings = Settings.builder()</span><br><span class="line">                .put(<span class="string">"cluster.name"</span>, <span class="string">"cluster-es"</span>).build();</span><br><span class="line">        <span class="comment">// 2. 创建ES传输客户端对象</span></span><br><span class="line">        TransportClient transportClient = <span class="keyword">new</span> PreBuiltTransportClient(settings);</span><br><span class="line">        <span class="comment">// 2.1 添加传输地址对象</span></span><br><span class="line">        transportClient.addTransportAddress(<span class="keyword">new</span></span><br><span class="line">                TransportAddress(InetAddress.getByName(<span class="string">"127.0.0.1"</span>), <span class="number">9301</span>));</span><br><span class="line">        transportClient.addTransportAddress(<span class="keyword">new</span></span><br><span class="line">                TransportAddress(InetAddress.getByName(<span class="string">"127.0.0.1"</span>), <span class="number">9302</span>));</span><br><span class="line">        transportClient.addTransportAddress(<span class="keyword">new</span></span><br><span class="line">                TransportAddress(InetAddress.getByName(<span class="string">"127.0.0.1"</span>), <span class="number">9303</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 创建内容构建对象</span></span><br><span class="line">        XContentBuilder builder = XContentFactory.jsonBuilder()</span><br><span class="line">                .startObject()</span><br><span class="line">                .field(<span class="string">"id"</span>, <span class="number">1</span>)</span><br><span class="line">                .field(<span class="string">"title"</span>, <span class="string">"elasticsearch搜索服务"</span>)</span><br><span class="line">                .field(<span class="string">"content"</span>,<span class="string">"ElasticSearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎。"</span>)</span><br><span class="line">                .endObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 执行索引库、类型、文档</span></span><br><span class="line">        transportClient.prepareIndex(<span class="string">"blog1"</span>,<span class="string">"article"</span>, <span class="string">"1"</span>)</span><br><span class="line">                .setSource(builder).get(); <span class="comment">// 执行请求</span></span><br><span class="line">        <span class="comment">// 5. 释放资源</span></span><br><span class="line">        transportClient.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 匹配全部 (集群环境) */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 创建Settings配置信息对象(主要配置集群名称)</span></span><br><span class="line">        Settings settings = Settings.builder()</span><br><span class="line">                .put(<span class="string">"cluster.name"</span>, <span class="string">"cluster-es"</span>).build();</span><br><span class="line">        <span class="comment">// 2. 创建ES传输客户端对象</span></span><br><span class="line">        TransportClient transportClient = <span class="keyword">new</span> PreBuiltTransportClient(settings);</span><br><span class="line">        <span class="comment">// 2.1 添加传输地址对象</span></span><br><span class="line">        transportClient.addTransportAddress(<span class="keyword">new</span></span><br><span class="line">                TransportAddress(InetAddress.getByName(<span class="string">"127.0.0.1"</span>), <span class="number">9301</span>));</span><br><span class="line">        transportClient.addTransportAddress(<span class="keyword">new</span></span><br><span class="line">                TransportAddress(InetAddress.getByName(<span class="string">"127.0.0.1"</span>), <span class="number">9302</span>));</span><br><span class="line">        transportClient.addTransportAddress(<span class="keyword">new</span></span><br><span class="line">                TransportAddress(InetAddress.getByName(<span class="string">"127.0.0.1"</span>), <span class="number">9303</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 创建搜索请求构建对象</span></span><br><span class="line">        SearchRequestBuilder searchRequestBuilder = transportClient</span><br><span class="line">                .prepareSearch(<span class="string">"blog1"</span>).setTypes(<span class="string">"article"</span>);</span><br><span class="line">        <span class="comment">// 3.1 设置查询条件(匹配全部)</span></span><br><span class="line">        searchRequestBuilder.setQuery(QueryBuilders.matchAllQuery());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 执行请求，得到搜索响应对象</span></span><br><span class="line">        SearchResponse searchResponse = searchRequestBuilder.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 获取搜索结果</span></span><br><span class="line">        SearchHits hits = searchResponse.getHits();</span><br><span class="line">        System.out.println(<span class="string">"总命中数："</span> + hits.totalHits);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 迭代搜索结果</span></span><br><span class="line">        <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">            System.out.println(<span class="string">"JSON字符串："</span> + hit.getSourceAsString());</span><br><span class="line">            System.out.println(<span class="string">"id: "</span> + hit.getSourceAsMap().get(<span class="string">"id"</span>));</span><br><span class="line">            System.out.println(<span class="string">"title: "</span> + hit.getSourceAsMap().get(<span class="string">"title"</span>));</span><br><span class="line">            System.out.println(<span class="string">"content: "</span> + hit.getSourceAsMap().get(<span class="string">"content"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 7. 释放资源</span></span><br><span class="line">        transportClient.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意: 修改cluster.name的集群名字保持和配置中的一致。</p><p><img src="/2020/02/16/Elasticsearch/1573542567904.png" alt="1573542567904"> </p><blockquote><p>说明: 测试关闭一个es节点，整个集群还是可以正常访问。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找法入门</title>
      <link href="/2020/01/05/%E4%BA%8C%E5%88%86%E6%B3%95%E5%85%A5%E9%97%A8/"/>
      <url>/2020/01/05/%E4%BA%8C%E5%88%86%E6%B3%95%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">代码演示：</span><br><span class="line"></span><br><span class="line"><span class="comment">/** versions=1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhonglchn</span></span><br><span class="line"><span class="comment"> * 个人案例： 计算机在指定范围内猜用户输入的数字，设计一个程序，不管用户输的什么数字，计算机最多只需要查找的次数。</span></span><br><span class="line"><span class="comment"> * 二分查找法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 查找的范围</span></span><br><span class="line">        <span class="keyword">int</span> notArr = <span class="number">18</span>;</span><br><span class="line">        <span class="comment">// number为需要猜测的数字</span></span><br><span class="line">        <span class="keyword">int</span> number = <span class="number">8</span>;</span><br><span class="line">        <span class="comment">// guess为你猜的数字，根据二分查找法</span></span><br><span class="line">        <span class="keyword">int</span> guess = notArr/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 初始化查找的次数</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 第一次查找的最大范围</span></span><br><span class="line">        <span class="keyword">int</span> max = notArr;</span><br><span class="line">        <span class="comment">// 第一次查找的最小范围</span></span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (guess != number) &#123;</span><br><span class="line">            <span class="comment">// 进来就代表查找了一次。</span></span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span> (guess &gt; number) &#123;</span><br><span class="line">                <span class="comment">// 上面定义了guess初始化为第一次，故做以下判断</span></span><br><span class="line">                <span class="keyword">if</span>(count==<span class="number">1</span>) &#123; max=max/<span class="number">2</span>; &#125;</span><br><span class="line">                guess = (max + min) / <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span>(guess &gt; number)&#123;</span><br><span class="line">                        max = guess;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        min = guess;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">               guess = (guess + max)/<span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span>(guess &gt; number)&#123;</span><br><span class="line">                       max = guess;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        min = guess;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为在循环外面就猜了一次，故需要+1；</span></span><br><span class="line">        System.out.println(count+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 - 入门案例 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入门 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 案例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>以前我有个朋友</title>
      <link href="/2020/01/04/aTa01/"/>
      <url>/2020/01/04/aTa01/</url>
      
        <content type="html"><![CDATA[<p>​    阿T啊：</p><p>​        我是个想要拼命抓住感情的人，不管是爱情还是友情。</p><p>我在亲情中没有得到足够的爱，在高中时期把一切的感情都压在了友情身上，用现在的话来说，我在友情里面是个卑微的舔狗。我一直认为只要用心对待，只要你拿出一颗心放在他们面前，他们迟早会拥抱你，毕竟我先跨出了那一步。</p><p>​        但是我忘记了不是人人都能体会到你的好，不是每个人都能看到你的，也不是每个人在你掏出心肺时张开双手是为了拥抱，还有的是为了夺取你的心跟他人炫耀。</p><p>​        L是我高一同学，高一我和她都在全校最好的班垫底，她热情开放，有很多朋友，不管是男生还是女生都很喜欢她。和她成为朋友是很偶然的机会，两个人座位分到一起，上课都不认真听课，于是走到一起，后来高二分班分开，我在二楼，她在三楼，我害怕她忘记我，只要有时间都会去找她，带着问候和零食。她没有下来看过我，我没有在乎，觉得她大概就是不喜欢联系的一个人。我告诉她，没钱了可以找我，在能力范围之类我会帮他解决。后来学业渐渐繁重，我不再去找她，她也没来找过我。高三分班后，我跟她初中一个好友在同一个班，我于是常常能见到她，虽然每次来她都只是找另一个女孩子，我还是觉得很开心。后来有一天，她在窗外很热情的跟我打招呼，我开心极了，她找我借钱，我很爽快的借给了她。很久之后的一天，我坐在了她初中朋友的前面，她从我身边走过，像是没有看见我，跟她朋友聊得热火朝天。我可能那一次真的知道什么叫，看过了她对别人的好，你才知道她是真的不在乎你。</p><p>​        我朋友跟我说，早就应该放弃，是你没有看透。</p><p>我一直是一个不撞南墙不回头的人，沉浸在自己的幻想中无法自拔，看不清前方的方向，也固执地不肯前进。两年后的某一天，她翻到了我给她写的信看到我的真心，她给我发消息说对不起，对不起错过这样的我。彼时的我早已穿起坚硬的铠甲，找到自己，我无法回应她迟钝的反应，就像我也不知道我该给自己一个什么交代一样，我只能够跟她说，没关系，我从未怪过她。</p><p>​        我怪的只有自己。</p><p>​        以前的朋友，不管对的错的，都能看见时光在身上流淌的痕迹，辜负和在意在多年后都成为青春的一道剪影，我从未怪过她，我把自己感动的一塌糊涂的日子，我奋不顾身的日子，我撞南墙不愿回头的日子，都是静静地能够看见的青春呀。</p><p>​        以前我有个朋友，他教会我很多事情，离开我的生活，奔赴了更加美好的人生。</p>]]></content>
      
      
      <categories>
          
          <category> 文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阿T啊 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git</title>
      <link href="/2020/01/01/Git/"/>
      <url>/2020/01/01/Git/</url>
      
        <content type="html"><![CDATA[<h2 id="第一部分：Git的简介与安装"><a href="#第一部分：Git的简介与安装" class="headerlink" title="第一部分：Git的简介与安装"></a>第一部分：Git的简介与安装</h2><h3 id="01、版本控制是什么？"><a href="#01、版本控制是什么？" class="headerlink" title="01、版本控制是什么？"></a>01、版本控制是什么？</h3><blockquote><p><strong>目标：</strong>掌握和了解Git是什么，在实际应用中处于什么角色。</p></blockquote><p><strong>需求</strong></p><p>在项目开发中，团队协作管理代码和文件是每天必须要做的事情。大家一定会碰到如下几个场景和问题？</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>：协同修改，多人并行开发修改服务器的文件</span><br><span class="line"><span class="number">2</span>：数据备份</span><br><span class="line"><span class="number">3</span>：版本管理，权限控制</span><br><span class="line"><span class="number">4</span>：如果文件和工程误删了还能找回来吗？</span><br><span class="line"><span class="number">5</span>：分支管理 <span class="number">1.0</span> <span class="number">2.0</span></span><br><span class="line"><span class="number">6</span>：遇到了文件冲突如何解决？</span><br><span class="line"><span class="number">7</span>：如何把一些我临时保存的文件不要提交?</span><br></pre></td></tr></table></figure><p>Svn版本控制软件: </p><p><img src="/2020/01/01/Git/1571966237833.png" alt="1571966237833"> </p><p>Git版本控制器软件: </p><p><img src="/2020/01/01/Git/1571966652553.png" alt="1571966652553"> </p><p><strong>小结</strong></p><ul><li>svn和git都是做版本控制的，如果不理解一句话: <strong>记录代码的轨迹</strong>就好比每个人的成长阶段一样。</li></ul><h3 id="02、Git的由来和发展史"><a href="#02、Git的由来和发展史" class="headerlink" title="02、Git的由来和发展史"></a>02、Git的由来和发展史</h3><blockquote><p><strong>目标</strong>：学习和掌握git的发展史及特点</p></blockquote><p><strong>概述</strong></p><p>同生活中的许多伟大事件一样，Git 诞生于一个极富纷争大举创新的年代。</p><p>Linux 内核开源项目有着为数众广的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上（1991－2002 年间）。到 2002 年，Linux 系统已经发展了十年了，代码库之大让 Linus 很难继续通过手工方式管理了，于是整个项目组开始启用分布式版本控制系统 BitKeeper 来管理和维护代码。 </p><p>到 2005 年的时候，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds ）不得不吸取教训，只有开发一套属于自己的版本控制系统才不至于重蹈覆辙。他们对新的系统订了若干目标： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">• 速度快 </span><br><span class="line">• 简单的设计 </span><br><span class="line">• 对非线性开发模式的强力支持（允许上千个并行开发的分支） </span><br><span class="line">• 完全分布式 </span><br><span class="line">• 有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）</span><br></pre></td></tr></table></figure><p>Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。</p><p>Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。</p><p>历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。</p><p><img src="/2020/01/01/Git/1571726570657.png" alt="1571726570657"> </p><h3 id="03、Git与Svn区别"><a href="#03、Git与Svn区别" class="headerlink" title="03、Git与Svn区别"></a>03、Git与Svn区别</h3><blockquote><p><strong>目标</strong>：Git与Svn区别</p></blockquote><h4 id="3-1-集中式版本控制（Svn）"><a href="#3-1-集中式版本控制（Svn）" class="headerlink" title="3.1 集中式版本控制（Svn）"></a>3.1 集中式版本控制（Svn）</h4><p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就郁闷了。</p><p>下图就是标准的集中式版本控制工具管理方式:</p><p><img src="/2020/01/01/Git/1571728355239.png" alt="1571728355239"> </p><p>集中管理方式在一定程度上看到其他开发人员在干什么，而管理员也可以很轻松掌握每个人的开发权限。</p><p>但是相较于其优点而言，集中式版本控制工具缺点很明显：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">服务器单点故障</span><br><span class="line">容错性差</span><br></pre></td></tr></table></figure><h4 id="3-2-分布式版本控制（Git）"><a href="#3-2-分布式版本控制（Git）" class="headerlink" title="3.2 分布式版本控制（Git）"></a>3.2 分布式版本控制（Git）</h4><p>Git是分布式版本控制系统，那么它可以没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p><p>下图就是分布式版本控制工具管理方式：</p><p><img src="/2020/01/01/Git/1571728415965.png" alt="1571728415965"> </p><p> <strong>小结</strong></p><ul><li>svn它集中式的版本控制，不能离线工作。git分布式的版本控制，它版本放在用户自己的电脑。</li><li>svn不支持离线工作，版本全部都放在是中央服务器。如果中央服务器挂了。那么版本全部丢失。</li><li>git支持离线工作。版本都放用户自己电脑上完成。—- 分布式的版本控制。</li><li>svn是项目对仓库，git是仓库对仓库。</li></ul><h3 id="04、GitHub和码云"><a href="#04、GitHub和码云" class="headerlink" title="04、GitHub和码云"></a>04、GitHub和码云</h3><blockquote><p><strong>目标：</strong>了解github与码云代码托管中心</p></blockquote><p>比较出名的代码托管中心: GitHub 和 码云</p><h4 id="4-1-什么是GitHub？"><a href="#4-1-什么是GitHub？" class="headerlink" title="4.1 什么是GitHub？"></a>4.1 什么是GitHub？</h4><p>确切的说 GitHub 是一家公司，位于旧金山，由 Chris Wanstrath, PJ Hyett 与 Tom Preston-Werner 三位开发者在2008年4月创办。这是它的 Logo：</p><p><img src="/2020/01/01/Git/clip_image004.jpg" alt="img">  </p><p>2008年4月10日，GitHub正式成立，地址：How people build software · GitHub ，主要提供基于git的版本托管服务。一经上线，它的发展速度惊为天人，截止目前，GitHub 已经发展成全球最大的开源社区。所以 Git 只是 GitHub 上用来管理项目的一个工具而已，GitHub 的功能可远不止于此！</p><h4 id="4-2-什么是码云？"><a href="#4-2-什么是码云？" class="headerlink" title="4.2 什么是码云？"></a>4.2 什么是码云？</h4><p>我们使用GitHub的时候，会感觉比较慢，为什么？ 原因就是GitHub在遥远的美国，由于各种原因造成访问速度不怎么好，所以国内的git服务提供商，码云就起来了。</p><p><img src="/2020/01/01/Git/1571727595825.png" alt="1571727595825"> </p><h4 id="4-3-产品功能对比"><a href="#4-3-产品功能对比" class="headerlink" title="4.3 产品功能对比"></a>4.3 产品功能对比</h4><table><thead><tr><th align="left">功能</th><th>码云 Gitee</th><th>GitHub</th></tr></thead><tbody><tr><td align="left">代码托管，支持 Git/SVN</td><td>√</td><td>√</td></tr><tr><td align="left">开源项目、代码片段</td><td>√</td><td>√</td></tr><tr><td align="left">Issue</td><td>√</td><td>√</td></tr><tr><td align="left">Wiki</td><td>√</td><td>√</td></tr><tr><td align="left">Fork + Pull Request</td><td>√</td><td>√</td></tr><tr><td align="left">组织</td><td>√</td><td>√</td></tr><tr><td align="left">私有仓库免费协作人数</td><td>5 人</td><td>3 人</td></tr><tr><td align="left">保护分支</td><td>免费</td><td>收费</td></tr><tr><td align="left">在线 IDE（Gitee IDE）</td><td>√</td><td>不支持</td></tr><tr><td align="left">仓库自动备份</td><td>√</td><td>不支持</td></tr><tr><td align="left">禁止 Git 强推</td><td>√</td><td>不支持</td></tr><tr><td align="left">支持仓库访问 IP 限制</td><td>√</td><td>不支持</td></tr><tr><td align="left">企业级研发协作</td><td>5 人免费</td><td>收费</td></tr><tr><td align="left">敏捷开发管理</td><td>√</td><td></td></tr><tr><td align="left">任务看板（可灵活定义）</td><td>√</td><td></td></tr><tr><td align="left">支持多级任务、关联任务</td><td>√</td><td></td></tr><tr><td align="left">自动代码质量分析</td><td>√</td><td></td></tr><tr><td align="left">快捷生成工作周报</td><td>√</td><td></td></tr><tr><td align="left">代码克隆检测</td><td>√</td><td></td></tr><tr><td align="left">自动生成 JavaDoc/PHPDoc</td><td>√</td><td></td></tr><tr><td align="left">多语言 README 自动渲染</td><td>√</td><td></td></tr><tr><td align="left">支持微信/钉钉通知</td><td>√</td><td></td></tr></tbody></table><h4 id="4-4-协作开发流程"><a href="#4-4-协作开发流程" class="headerlink" title="4.4 协作开发流程"></a>4.4 协作开发流程</h4><p><img src="/2020/01/01/Git/1571625695350.png" alt="1571625695350"> </p><h3 id="05、Git安装：客户端和服务端"><a href="#05、Git安装：客户端和服务端" class="headerlink" title="05、Git安装：客户端和服务端"></a>05、Git安装：客户端和服务端</h3><p><strong>前提</strong></p><ul><li>现在已经明白Git是一款版本控制工具。和Svn一样分为客户端和服务端。</li><li>服务端用来创建仓库保存文件的版本信息。客户端用来控制服务端的文件的维护操作。</li></ul><h4 id="5-1-下载"><a href="#5-1-下载" class="headerlink" title="5.1 下载"></a>5.1 下载</h4><p><a href="https://git-scm.com/download" target="_blank" rel="noopener">https://git-scm.com/download</a></p><p><img src="/2020/01/01/Git/1571728728098.png" alt="1571728728098"> </p><p><strong>安装教程：安装Git服务端</strong></p><blockquote><p>这是 windows 版本的 git 服务器；所以必须安装；安装说明详情见“资料”下的《Windows 系统安装 Git 2.14.1.docx》    </p></blockquote><h4 id="5-2-安装"><a href="#5-2-安装" class="headerlink" title="5.2 安装"></a>5.2 安装</h4><p>双击安装：</p><p><img src="/2020/01/01/Git/1573262288702.png" alt="1573262288702">&nbsp;</p><p><img src="/2020/01/01/Git/1573262034597.png" alt="1573262034597"> </p><p>一路“Next”使用默认选项即可。</p><p><img src="/2020/01/01/Git/1573262224843.png" alt="1573262224843"> </p><p>安装完成后，可以在任意文件夹点右键，看到如下菜单：</p><p><img src="/2020/01/01/Git/1573262669787.png" alt="1573262669787"> </p><p>新建D:\test文件夹，在test上面，点击Git的控制台，在控制台输入git，可以看到相关的帮助信息：</p><p><img src="/2020/01/01/Git/1573265813490.png" alt="1573265813490">  </p><h4 id="5-3-配置"><a href="#5-3-配置" class="headerlink" title="5.3 配置"></a>5.3 配置</h4><ul><li><p>配置签名: 用户名和邮箱(提交的用户名与邮箱)</p><ul><li><p>git config –global user.name “nameVal”</p></li><li><p>git config –global user.email “emailVal”</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name "lixiaohua"</span><br><span class="line">git config --global user.email "lixiaohua@itcast.cn"</span><br></pre></td></tr></table></figure><p><img src="/2020/01/01/Git/1573317337154.png" alt="1573317337154"></p><p><img src="/2020/01/01/Git/1571730311528.png" alt="1571730311528">  </p><p><img src="/2020/01/01/Git/1571730279226.png" alt="1571730279226"> </p><p>细节：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">局部的用户信息放在：当前项目的   .git&#x2F;config</span><br><span class="line">全局的用户信息放在：系统盘的--用户目录--用户名目录-- .gitconfig文件中</span><br><span class="line">                  [C:\Users\Administrator\.gitconfig]</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="第二部分：Git命令入门到精通"><a href="#第二部分：Git命令入门到精通" class="headerlink" title="第二部分：Git命令入门到精通"></a>第二部分：Git命令入门到精通</h2><h3 id="06、Git命令：创建版本库"><a href="#06、Git命令：创建版本库" class="headerlink" title="06、Git命令：创建版本库"></a>06、Git命令：创建版本库</h3><blockquote><p><strong>目标：</strong>知道什么是版本库，并且创建它</p></blockquote><p>  什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。由于git是分布式版本管理工具，所以git在不需要联网的情况下也具有完整的版本管理能力。</p><p>创建一个版本库非常简单:</p><ul><li><p>首先，选择一个合适的地方，创建一个空目录。在D:\test目录下，创建了一个hello目录： <img src="/2020/01/01/Git/clip_image023.jpg" alt="img"></p></li><li><p>使用git init命令把这个目录变成Git可以管理的仓库：<img src="/2020/01/01/Git/clip_image025.jpg" alt="img"></p></li><li><p>命令输入后，你已经创建了一个空的Git仓库。此时你会在hello目录下发现一个隐藏目录.git <img src="/2020/01/01/Git/clip_image027.jpg" alt="img"></p><p>这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。</p><p>此处的hello目录就是我们的：<strong>工作区 (work tree)</strong>，存放所有当前文档。此目录下的文件才会被Git管理，hello中的.git目录就是我们的：<strong>本地仓库</strong>，管理并保存所有的文档变化及历史状态。</p></li></ul><p><strong>版本库核心文件的解释</strong></p><table><thead><tr><th align="center">目录</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">config</td><td align="left">该文件主要记录针对该项目的一些配置信息，例如是否以bare方式初始化、remote的信息等，通过git remote add命令增加的远程分支的信息就保存在这里；</td></tr><tr><td align="center">objects</td><td align="left">Git中的文件和一些操作都会以git对象来保存，git对象分为BLOB、tree和commit三种类型，例如git commit便是git中的commit对象，而各个版本之间是通过<strong>版本树</strong>来组织的，比如当前的HEAD会指向某个commit对象，而该commit对象又会指向几个BLOB对象或者tree对象。</td></tr><tr><td align="center">HEAD</td><td align="left">该文件指明了git branch（即当前分支）的结果，比如当前分支是master，则该文件就会指向master，但是并不是存储一个master字符串，而是分支在refs中的表示，例如ref: refs/heads/master</td></tr><tr><td align="center">index</td><td align="left">该文件保存了暂存区域的信息。该文件某种程度就是缓冲区（staging area），内容包括它指向的文件的时间戳、文件名、sha1值等；</td></tr><tr><td align="center">Refs</td><td align="left">该文件夹存储指向数据（分支）的提交对象的指针。</td></tr></tbody></table><p><strong>小结</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">创建版本库的步骤：</span><br><span class="line"><span class="number">1.</span> 进入需要管理的目录</span><br><span class="line"><span class="number">2.</span> 执行 git init 命令</span><br></pre></td></tr></table></figure><h3 id="07、Git命令：添加文件并提交"><a href="#07、Git命令：添加文件并提交" class="headerlink" title="07、Git命令：添加文件并提交"></a>07、Git命令：添加文件并提交</h3><blockquote><p><strong>目标：</strong>Git是如何在仓库中添加文件并提交到本地仓库?</p></blockquote><p>  版本控制系统，其目的就是跟踪文本文件的改动，例如我们开发时编写的.java、.properties本质都是文本文件。文件中每一个字符的变化都会被跟踪并且管理。</p><p><img src="/2020/01/01/Git/1552015317597.png" alt="1552015317597"></p><p><img src="/2020/01/01/Git/1551861304830.png" alt="1551861304830"></p><ul><li><p>我们在当前的hello目录下创建一个新的文本文件：readme.txt</p><p><img src="/2020/01/01/Git/clip_image029.jpg" alt="img">  </p><p><img src="/2020/01/01/Git/clip_image031.jpg" alt="img">  </p></li><li><p>编写一段文字：hello Git!</p><p><img src="/2020/01/01/Git/clip_image033.jpg" alt="img">  </p></li><li><p>接下来，我们使用 git add 命令，将文件添加到暂存区<img src="/2020/01/01/Git/clip_image035.jpg" alt="img"></p><p>没有任何的反应，证明没有问题。</p></li><li><p>使用 git commit 命令，将暂存区文件提交到本地仓库<img src="/2020/01/01/Git/clip_image037.jpg" alt="img"></p></li></ul><p><strong>命令解释</strong>:</p><p>   git commit 命令可以将暂存区的文件提交到版本库。</p><p>   -m 参数，是本次提交的说明信息，用来注释本次提交做了些说明事情。</p><p>*<em>总结: *</em>将一个文件添加到本地仓库，分两步：</p><ul><li>使用 git add <file> 命令，添加文件。可以一次添加多个文件。</file></li><li>使用 git commit -m ‘’ 命令，提交，一次即可。</li></ul><p>可能大家会有疑问，为什么这里不是直接commit提交，而是要经过add和commit两个步骤呢？</p><p>这就关系到Git的版本库中的 工作区 暂存区概念了。</p><h3 id="08、Git概念：工作区、暂存区、版本库"><a href="#08、Git概念：工作区、暂存区、版本库" class="headerlink" title="08、Git概念：工作区、暂存区、版本库"></a>08、Git概念：工作区、暂存区、版本库</h3><blockquote><p><strong>目标：</strong>理解Git 工作区、暂存区和版本库概念</p></blockquote><p><strong>工作区：</strong></p><ul><li><p>工作区就是你在电脑里能看到的目录。比如我们刚刚创建的hello目录：</p><p><img src="/2020/01/01/Git/clip_image039.jpg" alt="img">  </p><p>其中包含了一个隐藏目录 .git ，其它就是我们需要被管理的文件。</p></li></ul><p><strong>版本库及暂存区：</strong></p><ul><li>工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。</li><li>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。</li></ul><p>​     <img src="/2020/01/01/Git/clip_image041.jpg" alt="img"> &nbsp; </p><p>前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：</p> <figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一步是用git <span class="keyword">add</span><span class="bash">把文件添加进去，实际上就是把文件修改添加到暂存区；</span></span><br><span class="line">第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。</span><br></pre></td></tr></table></figure><p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。</p><p><strong>小结：</strong>你可以简单理解为，需要提交的文件通通放到暂存区，然后，一次性提交暂存区到版本库。</p><h3 id="09、Git命令：文件的修改、状态、日志"><a href="#09、Git命令：文件的修改、状态、日志" class="headerlink" title="09、Git命令：文件的修改、状态、日志"></a>09、Git命令：文件的修改、状态、日志</h3><blockquote><p><strong>目标：</strong>掌握文件的修改以及修改的提交及状态日志的查看</p></blockquote><ul><li><p>被版本库管理的文件不可避免的要发生修改，此时只需要直接对文件修改即可。修改完毕后需要将文件的修改提交到版本库。</p></li><li><p>我们对readme.txt文件进行修改，添加一行数据：</p><p><img src="/2020/01/01/Git/1571732075149.png" alt="1571732075149"> </p></li></ul><h4 id="9-1-比较差异"><a href="#9-1-比较差异" class="headerlink" title="9.1 比较差异"></a>9.1 比较差异</h4><hr><p><img src="/2020/01/01/Git/1571734415542.png" alt="1571734415542"> </p><p>用<code>git diff HEAD readme.txt</code>命令可以查看工作区和版本库里面最新版本的区别：</p><p><img src="/2020/01/01/Git/1574260385565.png" alt="1574260385565"> </p><p>可以发现，与版本库中的 readme.txt相比，我们多了一行文本！</p><h4 id="9-2-查看修改状态"><a href="#9-2-查看修改状态" class="headerlink" title="9.2 查看修改状态"></a>9.2 查看修改状态</h4><hr><p>我们如果不确定自己的哪些文件被修改了，可以使用git status命令，查看当前工作区的状态： <img src="/2020/01/01/Git/clip_image047.jpg" alt="img"> </p><p>可以清楚的看到：changes not staged for commit（修改没有被缓存，需要使用git add来进行添加操作）,我们使用git add 命令，添加到暂存区：</p><p><img src="/2020/01/01/Git/clip_image049.jpg" alt="img"> </p><p>再次查看状态：</p><p><img src="/2020/01/01/Git/clip_image051.jpg" alt="img"> </p><p>这次提示： changes to be commited （修改需要被提交），我们使用git commit 进行提交<img src="/2020/01/01/Git/clip_image053.jpg" alt="img"></p><p>再次查看状态：</p><p><img src="/2020/01/01/Git/clip_image055.jpg" alt="img"> </p><p>提示说：工作区很干净，没有任何需要提交，搞定！</p><p>再次修改readme.txt 新增内容: Test version control. 提交到版本库<img src="/2020/01/01/Git/1573270158812.png" alt="1573270158812">)<img src="/2020/01/01/Git/1573270445099.png" alt="1573270445099"></p><h4 id="9-3-查看日志"><a href="#9-3-查看日志" class="headerlink" title="9.3 查看日志"></a>9.3 查看日志</h4><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log  整体展示，不直观，如果要翻页，一直按enter键进行翻页，按CTRL+C退出</span><br></pre></td></tr></table></figure><p><img src="/2020/01/01/Git/1571733099690.png" alt="1571733099690"> </p><p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>(一行显示)参数：</p><p><img src="/2020/01/01/Git/clip_image063.jpg" alt="img"> </p><ul><li><p>可以发现，目前为止，我们已经在本地仓库中提交了3次，也就是说有3个不同版本。其中，最近的这个版本有一个标示：HEAD ，这就是标记当前分支的当前版本所在位置。本例当中，当前版本即 test version control这次提交。</p></li><li><p>另外，在log中，每一个版本的前面，都有一长串随即数字：5bc7781319b…192728 ，这是每次提交的commit id ，这是通过SHA1算法得到的值，Git通过这个唯一的id来区分每次提交。</p></li><li><p>美化的缩小版</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline</span><br></pre></td></tr></table></figure><p><img src="/2020/01/01/Git/1573270628606.png" alt="1573270628606">&nbsp;</p></li></ul><p><strong>小结</strong></p><ul><li>git diff</li><li>git status</li><li>git log –oneline</li></ul><h3 id="10、Git命令：版本回退"><a href="#10、Git命令：版本回退" class="headerlink" title="10、Git命令：版本回退"></a>10、Git命令：版本回退</h3><blockquote><p><strong>目标：</strong>使用git命令git reset 找回文件回退到历史版本</p></blockquote><p>现在，假设我们要回到上一级版本，该如何操作呢？</p><ul><li>首先，Git通过HEAD来判断当前所在的版本位置。那么上一个版本，就用HEAD^标示，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。</li><li>如果要从 “test version control” 回退到 “modify readme file” ，我们可以使用 git reset 命令。</li></ul><h4 id="10-1-查看所有关联日志"><a href="#10-1-查看所有关联日志" class="headerlink" title="10.1 查看所有关联日志"></a>10.1 查看所有关联日志</h4><p>我们可以通过git reflog命令，看到以前的每次执行动作:</p><p><img src="/2020/01/01/Git/1573273912620.png" alt="1573273912620"></p><p>其中红框内的部分，就是我们第三次提交的日志信息。前面的Obd575f就是第三次提交的 commit id 的前几位数字。</p><h4 id="10-2-回退到某个版本"><a href="#10-2-回退到某个版本" class="headerlink" title="10.2 回退到某个版本"></a>10.2 回退到某个版本</h4><ul><li><p>语法: git reset –hard ‘版本号’</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 0712188</span><br></pre></td></tr></table></figure><p><img src="/2020/01/01/Git/1573271252228.png" alt="1573271252228"> </p><p> 提示说：HEAD 现在已经被设置到 0712188 的版本，即 modify readme file。</p><p> 我们查看readme.txt： </p><p> <img src="/2020/01/01/Git/1573271334498.png" alt="1573271334498"></p><p> 果然，版本已经回退了，最新添加的数据“Test version control”已经没了。</p><p> 此时再次查看日志，发现只剩下2次提交信息了，第三次提交的信息已经没了:</p><p> <img src="/2020/01/01/Git/clip_image069.jpg" alt="img"> </p></li></ul><p>​    假如此时我后悔了，还想回到第3次提交的版本，怎么办?</p><ul><li><ul><li><p>查看日志，得到版本号，回退指定版本：</p><p><img src="/2020/01/01/Git/1573274558778.png" alt="1573274558778">)查看文件：(数据又回来了！)</p><p><img src="/2020/01/01/Git/clip_image077.jpg" alt="img"> </p></li></ul></li></ul><p><strong>总结：</strong></p><p> 如果要进行版本回退，一般分两步:</p><ul><li><p>通过 git log 或 git reflog 查看操作日志吗，查找版本的commit id(版本号)</p></li><li><p>通过 git reset –hard <commit id> 设置HEAD到指定版本</commit></p><p>其实版本的回退，仅仅是修改HEAD指针的位置而已，因此Git进行版本的切换，比svn要快的多！</p></li></ul><p><img src="/2020/01/01/Git/1571972378334.png" alt="1571972378334"> </p><p><img src="/2020/01/01/Git/1571972348985.png" alt="1571972348985"> </p><h3 id="11、Git命令：撤销修改"><a href="#11、Git命令：撤销修改" class="headerlink" title="11、Git命令：撤销修改"></a>11、Git命令：撤销修改</h3><blockquote><p><strong>目标：</strong>掌握文件修改的撤销</p></blockquote><h4 id="11-1-撤销工作区修改"><a href="#11-1-撤销工作区修改" class="headerlink" title="11.1 撤销工作区修改"></a>11.1 撤销工作区修改</h4><p>现在我们在readme.txt中添加一行数据:</p><p><img src="/2020/01/01/Git/clip_image079.jpg" alt="img"> </p><ul><li>在你提交前，你突然发现这个修改是有问题的，你打算恢复到原来的样子。怎么办？</li><li>如果修改的并不多，我们完全可以手动恢复到原始状态。但是如果改动比较大，手动处理就很容易有遗漏，而且很麻烦。怎么办？</li></ul><p>查看状态:</p><p><img src="/2020/01/01/Git/clip_image081.jpg" alt="img"> </p><p>Git提示我们，现在文件已经修改，等待被staged（暂存）。我们有两个选择：</p><ul><li>可以使用git add 来添加到暂存区，接着去提交文件。</li><li>可以使git checkout – <file> 来撤销修改。</file></li></ul><p>所以，这里我们选择第二种方案：</p><p><img src="/2020/01/01/Git/clip_image083.jpg" alt="img"> </p><p>再次查看状态：</p><p><img src="/2020/01/01/Git/clip_image085.jpg" alt="img"> </p><p>工作区是干净的！查看文件：</p><p><img src="/2020/01/01/Git/clip_image087.jpg" alt="img"> </p><p>修改已经被撤销了！</p><h4 id="11-2-撤销staged（暂存区）修改"><a href="#11-2-撤销staged（暂存区）修改" class="headerlink" title="11.2 撤销staged（暂存区）修改"></a>11.2 撤销staged（暂存区）修改</h4><ul><li>刚才的案例中，我们修改了数据，并没有add带暂存区，处理起来还算简单。</li><li>如果我们已经把数据add 到了暂存区，又该如何处理呢？我们首先添加一行数据到readme.txt</li></ul><p><img src="/2020/01/01/Git/clip_image089.jpg" alt="img"> </p><ul><li>并且添加到staged（暂存区），然后查看状态:</li></ul><p><img src="/2020/01/01/Git/clip_image091.jpg" alt="img"> </p><ul><li>有一个修改等待被提交，并且有一行提示:</li></ul><p><img src="/2020/01/01/Git/clip_image093.jpg" alt="img"> </p><ul><li>可以使用 git reset HEAD <file> 来撤销缓存修改。</file></li></ul><p>我们前面说过，git reset 命令可以进行版本回退，此处reset 指定的是HEAD ，而不是其他版本，因此就有撤销缓存修改的作用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD readme.txt</span><br></pre></td></tr></table></figure><p><img src="/2020/01/01/Git/clip_image095.jpg" alt="img"> </p><p>查看状态：</p><p><img src="/2020/01/01/Git/clip_image097.jpg" alt="img"> </p><p>发现文件的修改被撤回到了工作区，尚未添加到staged（暂存区），我们再次执行git checkout – <file> 即可撤销工作区修改</file></p><p><img src="/2020/01/01/Git/clip_image099.jpg" alt="img"> </p><p>工作区干净了！查看文件：</p><p><img src="/2020/01/01/Git/clip_image101.jpg" alt="img"> </p><p>文件也恢复了原来的状态，整个世界都清净了！</p><p><strong>小结：</strong></p><p>撤销修改分两种情况:</p><ul><li><p>撤销<strong>工作区</strong>修改，使用git checkout – <file></file></p></li><li><p>撤销<strong>暂存区</strong>修改，分两步：</p><ul><li><p>使用git reset HEAD <file>来撤销暂存区修改。</file></p></li><li><p>使用git checkout – <file>来撤销工作区修改。</file></p></li></ul></li></ul><h3 id="12、Git：忽略文件"><a href="#12、Git：忽略文件" class="headerlink" title="12、Git：忽略文件"></a>12、Git：忽略文件</h3><p><strong>问题</strong></p><p>  往往在开发的过程中，特别是在多人协作的场景下，可能需要把一些无用的文件不需要提交。GIT是如何来做的的呢？ 项目 </p><p><strong>图解</strong></p><p><img src="/2020/01/01/Git/1552017055333.png" alt="1552017055333"></p><p><strong>在当前工作区创建忽略文件：.gitignore</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1: 打开`git bash here` 输入如下命令：</span></span><br><span class="line">vim .gitignore</span><br><span class="line">target</span><br><span class="line">*.iml</span><br><span class="line">.idea</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2: 保存退出 </span></span><br><span class="line">:wq</span><br></pre></td></tr></table></figure><p>gitignore 语法规则:</p><blockquote><p>空行或是以 # 开头的行即 注释行，将会被忽略。 </p><p>示例如下：</p><p># 忽略所有 .a 文件</p><p><code>*.a</code></p><p># 递归忽略 build/ 文件夹下的所有文件</p><p><code>build</code></p><p># 忽略 /doc/notes.txt,不包括 doc/server/arch.txt</p><p><code>doc/*.txt</code></p><p># 忽略所有的 .pdf 文件 在 doc/ directory 下的</p><p><code>doc/**/*.pdf</code></p></blockquote><h2 id="第三部分：Git的远程仓库【重点】"><a href="#第三部分：Git的远程仓库【重点】" class="headerlink" title="第三部分：Git的远程仓库【重点】"></a>第三部分：Git的远程仓库【重点】</h2><h3 id="13、远程仓库：注册、创建仓库、推送"><a href="#13、远程仓库：注册、创建仓库、推送" class="headerlink" title="13、远程仓库：注册、创建仓库、推送"></a>13、远程仓库：注册、创建仓库、推送</h3><p><strong>问题</strong></p><ul><li><p>之前我们讲的文件版本控制都是在本机的本地仓库中进行操作，如何进行团队协作开发，怎么把我们本地仓库的代码共享出来供团队的其他开发员下载使用呢？</p><p><strong>没错就是：远程仓库。</strong></p></li></ul><h4 id="13-1-介绍"><a href="#13-1-介绍" class="headerlink" title="13.1 介绍"></a>13.1 介绍</h4><p>到目前为止，我们已经学会了如何在本机利用git进行文件版本管理，但是如果要想进行多人协作，我们就必须使用远程仓库。将本地仓库的数据同步到远程仓库，实现多人协作开发。</p><ul><li><p>目前比较热门的代码托管社区：GitHub，网址：<a href="https://gtihub.com" target="_blank" rel="noopener">https://gtihub.com</a> ,提供了免费的远程git仓库功能。不过网速不是特别流畅。</p></li><li><p>在国内，有很多的公司使用oschina提供的git服务：码云, <a href="https://gitee.com。" target="_blank" rel="noopener">https://gitee.com。</a></p></li><li><p>也可以自己搭建：gitlab。</p><p><img src="/2020/01/01/Git/1552011927979.png" alt="1552011927979"></p></li></ul><h4 id="13-2-github"><a href="#13-2-github" class="headerlink" title="13.2 github"></a>13.2 github</h4><ul><li><p>注册 <a href="https://github.com/join" target="_blank" rel="noopener">https://github.com/join</a> </p><p><img src="/2020/01/01/Git/1551778168169.png" alt="1551778168169">&nbsp;</p></li><li><p>创建远程仓库</p></li></ul><p><img src="/2020/01/01/Git/1573285784447.png" alt="1573285784447"> <img src="/2020/01/01/Git/1573285893795.png" alt="1573285893795"></p><ul><li>详细介绍远程仓库</li></ul><p><img src="/2020/01/01/Git/1551778325768.png" alt="1551778325768">&nbsp;</p><h4 id="13-3-码云"><a href="#13-3-码云" class="headerlink" title="13.3 码云"></a>13.3 码云</h4><ul><li><p>注册: <a href="https://gitee.com/signup" target="_blank" rel="noopener">https://gitee.com/signup</a></p><p><img src="/2020/01/01/Git/1562118994650.png" alt="1562118994650"></p></li><li><p>创建远程仓库</p><ul><li><p>在页面右侧，选择创建新的仓库</p><p><img src="/2020/01/01/Git/1573286509957.png" alt="1573286509957"> </p></li><li><p>填写仓库信息:</p><p><img src="/2020/01/01/Git/1573286805103.png" alt="1573286805103"></p><p><img src="/2020/01/01/Git/1573287031824.png" alt="1573287031824"> </p></li><li><p>仓库创建完毕，可以看到，如果我们要与远程仓库同步，这里支持两种不同的通信协议，ssh和http。当我们选中一种协议后，后面会出现对应的远程仓库地址。</p><p><img src="/2020/01/01/Git/1573287264904.png" alt="1573287264904"> </p></li></ul></li></ul><h4 id="13-4-关联远程仓库"><a href="#13-4-关联远程仓库" class="headerlink" title="13.4 关联远程仓库"></a>13.4 关联远程仓库</h4><p><img src="/2020/01/01/Git/1552013586401.png" alt="1552013586401"></p><ul><li><p>操作步骤</p><ul><li><p>添加或删除关联远程仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin url   # 为当前本地仓库添加关联的远程仓库</span><br><span class="line">git remote rm origin        # 从当前本地仓库中删除关联的远程仓库</span><br></pre></td></tr></table></figure><p>origin: 为远程仓库起个别名</p><p>url: 远程url</p></li><li><p>添加本地仓库和远程仓库关联-<strong>https</strong>连接 (第一种方式)</p><p><img src="/2020/01/01/Git/1573288233369.png" alt="1573288233369"></p><p><img src="/2020/01/01/Git/1573288162164.png" alt="1573288162164"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 执行此命令必须要进入该仓库对应的工作区</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> github</span></span><br><span class="line">git remote add origin https://github.com/lixiaohua1/gitdemo.git</span><br><span class="line"><span class="meta">#</span><span class="bash"> 码云</span></span><br><span class="line">git remote add origin2 https://gitee.com/leesiuwah/gitdemo.git</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果删除之前关联：</span></span><br><span class="line">git remote rm origin</span><br><span class="line">git remote add origin 改成新的地址</span><br></pre></td></tr></table></figure><p>注: 初次关联使用提交代码的时候需要填写，账号和密码信息(为github 或 码云 的登录用户名与密码)。用户名：<a href="mailto:lixiaohua@itcast.cn">lixiaohua@itcast.cn</a> 密码: xxxxx</p><p>【稍后再使用】: 添加本地仓库和远程仓库关联-<strong>ssh</strong>连接（第二种方式: 免密)</p></li></ul></li></ul><ul><li><p>同步本地仓库到远程仓库的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 同步本地仓库到远程仓库</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> github</span></span><br><span class="line">git push -u origin master</span><br><span class="line"><span class="meta">#</span><span class="bash"> 码云</span></span><br><span class="line">git push -u origin2 master</span><br></pre></td></tr></table></figure><p><img src="/2020/01/01/Git/1573289308393.png" alt="1573289308393">   </p><p>注：origin 可以理解为远程仓库的别名，master 主分支。</p></li></ul><h3 id="14、远程仓库：克隆远程仓库到本机"><a href="#14、远程仓库：克隆远程仓库到本机" class="headerlink" title="14、远程仓库：克隆远程仓库到本机"></a>14、远程仓库：克隆远程仓库到本机</h3><blockquote><p><strong>目标:</strong> 如何克隆远程仓库到本机呢？</p></blockquote><p><img src="/2020/01/01/Git/1552012770907.png" alt="1552012770907"></p><p><strong>操作命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 克隆远程仓库到本机</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> git <span class="built_in">clone</span> ssh/https </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> github</span></span><br><span class="line">git clone https://github.com/lixiaohua1/gitdemo.git</span><br><span class="line"><span class="meta">#</span><span class="bash"> 码云</span></span><br><span class="line">git clone https://gitee.com/leesiuwah/gitdemo.git</span><br></pre></td></tr></table></figure><p><img src="/2020/01/01/Git/1573291519356.png" alt="1573291519356"> </p><p><strong>注意：新克隆下来的远程仓库访问名称默认为 origin</strong></p><h3 id="15、远程仓库：同步远程仓库到本地仓库"><a href="#15、远程仓库：同步远程仓库到本地仓库" class="headerlink" title="15、远程仓库：同步远程仓库到本地仓库"></a>15、远程仓库：同步远程仓库到本地仓库</h3><blockquote><p><strong>目标：</strong>如何同步远程仓库的代码到本地仓库到呢？</p></blockquote><p><img src="/2020/01/01/Git/1551861817226.png" alt="1551861817226"></p><p><strong>git命令</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新远程仓库到本地仓库</span></span><br><span class="line">git pull origin master</span><br></pre></td></tr></table></figure><p><img src="/2020/01/01/Git/1573293117681.png" alt="1573293117681"> </p><p><strong>如果出现如下问题</strong></p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> ! [rejected]  master -&gt; master (fetch first)</span><br><span class="line"><span class="keyword">error</span>: failed to push some refs to 'https://gitee.com/kekesam/pingyougou2.git'</span><br><span class="line">hint: Updates were rejected because the remote contains work that you do</span><br><span class="line">hint: not have locally. This is usually caused by another repository pushing</span><br><span class="line">hint: to the same ref. You may want to first integrate the remote changes</span><br><span class="line">hint: (e.g., 'git pull ...') before pushing again.</span><br><span class="line">hint: See the 'Note about fast-forwards' in 'git push --help' <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure><p><strong>解决方案</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f origin master</span><br></pre></td></tr></table></figure><p>说明: 它会把远程仓库中所有的信息全部清空，在把本机仓库版本提交上去。</p><h3 id="16、远程仓库：SSH连接和注意事项"><a href="#16、远程仓库：SSH连接和注意事项" class="headerlink" title="16、远程仓库：SSH连接和注意事项"></a>16、远程仓库：SSH连接和注意事项</h3><blockquote><p><strong>目标</strong>：掌握ssh协议免密的配置</p></blockquote><ul><li><p>连接远程仓库，势必会进行其用户验证，这个时候需要频繁的输入用户的账号信息，有没有一种能够免密的操作呢？为什么我们连接好以后就不需要配置用户名和密码了呢？因为windows10系统会帮我们记录用户的凭据信息可以在【控制面板】—凭据管理中获得。</p><p><img src="/2020/01/01/Git/1571735966405.png" alt="1571735966405"> </p></li><li><p>但是很遗憾的是: 在window7系统中没有这种凭据，https的这种方式可能就会出现一个现象就是频繁的数据用户名和密码，这样就是一件繁琐的操作，如何解决呢？没错使用ssh的方式来进行连接。</p><p>SSH架构: Struts2 + Spring + Hibernate。我们说得是ssh协议。</p></li></ul><h4 id="16-1-什么是SSH协议"><a href="#16-1-什么是SSH协议" class="headerlink" title="16.1 什么是SSH协议"></a>16.1 什么是SSH协议</h4><ul><li>SSH是英文Secure Shell的简写形式。通过使用SSH，你可以把所有传输的数据进行加密，这样”中间人”这种攻击方式就不可能实现了，而且也能够防止DNS欺骗和IP欺骗。</li><li>使用SSH，还有一个额外的好处就是传输的数据是经过压缩的，所以可以加快传输的速度。SSH有很多功能，它既可以代替Telnet，又可以为FTP、Pop、甚至为PPP提供一个安全的”通道”。</li><li>如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。</li><li>最早的时候，互联网通信都是明文通信，一旦被截获，内容就暴露无疑。1995年，芬兰学者Tatu Ylonen设计了SSH协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为Linux系统的标准配置。</li></ul><h4 id="16-2-创建SSH密钥"><a href="#16-2-创建SSH密钥" class="headerlink" title="16.2 创建SSH密钥"></a>16.2 创建SSH密钥</h4><ul><li><p>Git-bash中已经集成了ssh功能，所以我们只需要简单的命令，即可生成密钥:</p><p>命令: ssh-keygen -t rsa</p><p> 一路回车向下走，不要输入任何内容即可！</p><p> ssh-keygen -t rsa  一路三个回车</p><p> <img src="/2020/01/01/Git/clip_image113.jpg" alt="img"> </p></li><li><p>执行命令完成后, 在C:\Users\Administrator<code>\</code>.ssh下面生成如下名称的公钥和私钥:</p><p><img src="/2020/01/01/Git/1573294004878.png" alt="1573294004878"> </p><p><img src="/2020/01/01/Git/1552012491019.png" alt="1552012491019">&nbsp;</p></li><li><p>具体步骤如下:</p><p>第一步: 打开命令工具”git bash here” 输入命令 “<strong>ssh-keygen -t rsa</strong>” 生成密钥和公钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p>第二步: 然后将<code>C:\Users\Administrator\.ssh</code>生成的公钥文件【id_rsa.pub】内容复制出来</p><p>第三步: </p><ul><li><p>打开gitee官网–【登录】–【设置】-【SSH公钥】选项如下图：</p><p><img src="/2020/01/01/Git/1573295254445.png" alt="1573295254445"></p></li><li><p>打开github官网–【登录】–【settings】-【SSH and GPG keys】选项如下图：</p><p><img src="/2020/01/01/Git/1573295578961.png" alt="1573295578961"></p><p><img src="/2020/01/01/Git/1573295703584.png" alt="1573295703584"></p></li></ul><p>第四步: 测试和体验ssh的免密操作</p><ul><li><p>添加远程仓库和本地仓库的关联：(origin 是默认的远程版本库名称)</p><p><img src="/2020/01/01/Git/1573289084106.png" alt="1573289084106"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> github</span></span><br><span class="line">git remote add origin git@github.com:lixiaohua1/gitdemo.git</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 码云</span></span><br><span class="line">git remote add origin2 git@gitee.com:leesiuwah/gitdemo.git</span><br></pre></td></tr></table></figure><p><img src="/2020/01/01/Git/1573313341064.png" alt="1573313341064"></p><p>提示：如果你想更换远程仓库的地址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin      #删除原来的origin</span><br><span class="line">git remote rm origin2     #删除原来的origin2</span><br><span class="line">  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 然后在执行</span></span><br><span class="line">git remote add origin 你需要更换的远程仓库地址</span><br></pre></td></tr></table></figure></li><li><p>提交代码到远程仓库中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br><span class="line">git push origin2 master</span><br></pre></td></tr></table></figure></li><li><p>克隆远程仓库到本机:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> github</span></span><br><span class="line">git clone git@github.com:lixiaohua1/gitdemo.git</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 码云</span></span><br><span class="line">git clone git@gitee.com:leesiuwah/gitdemo.git</span><br></pre></td></tr></table></figure><p><strong>注意：新克隆下来的远程仓库访问名称默认为 origin</strong></p></li><li><p>拉取最新代码到本机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure><blockquote><p>注意：记得将https地址更换ssh地址。</p></blockquote></li></ul></li></ul><h3 id="17、分支管理：合并分支、切换分支"><a href="#17、分支管理：合并分支、切换分支" class="headerlink" title="17、分支管理：合并分支、切换分支"></a>17、分支管理：合并分支、切换分支</h3><p>  分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。</p><p><img src="/2020/01/01/Git/1571989886482.png" alt="1571989886482"> </p><p>文件提交的过程:</p><p><img src="/2020/01/01/Git/1551862269717.png" alt="1551862269717"> </p><p>新建分支与切换分支:</p><p><img src="/2020/01/01/Git/1551862657349.png" alt="1551862657349"> </p><p>合并分支:</p><p><img src="/2020/01/01/Git/1551863332557.png" alt="1551863332557">  </p><ul><li><p>第一步：创建分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git branch dev   创建分支 dev</span><br><span class="line">git checkout dev  选中当前分支  dev</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注：上面两个命令可以组合成一个复合命令</span></span><br><span class="line">git checkout -b dev</span><br><span class="line"><span class="meta">#</span><span class="bash"> git checkout -b dev  = （git branch dev +  git checkout dev）</span></span><br></pre></td></tr></table></figure><p><img src="/2020/01/01/Git/1573315324231.png" alt="1573315324231"></p><p><img src="/2020/01/01/Git/1573315417906.png" alt="1573315417906"></p></li><li><p>第二步：查看分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><p><img src="/2020/01/01/Git/1573315498108.png" alt="1573315498108"></p></li><li><p>第三步：添加文件，提交文件在当前分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建文件，输入任意内容</span></span><br><span class="line">vim e.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交e.txt文件</span></span><br><span class="line">git add .</span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交e.txt文件到dev分支中</span></span><br><span class="line">git commit -m 'e.txt'</span><br></pre></td></tr></table></figure></li><li><p>第四步：推送分支到远程仓库中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin dev</span><br></pre></td></tr></table></figure><p><img src="/2020/01/01/Git/1573315908217.png" alt="1573315908217">&nbsp;</p></li><li><p>第五步：合并分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 切换回master分支</span></span><br><span class="line">git checkout master</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将dev下面的内容全部合并到master</span></span><br><span class="line">git merge dev</span><br></pre></td></tr></table></figure><p><img src="/2020/01/01/Git/1573316053364.png" alt="1573316053364"></p></li><li><p>第六步：删除分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d dev</span><br></pre></td></tr></table></figure><p><img src="/2020/01/01/Git/1573316103994.png" alt="1573316103994">    </p></li></ul><h2 id="第四部分：-客户端TortoiseGit"><a href="#第四部分：-客户端TortoiseGit" class="headerlink" title="第四部分： 客户端TortoiseGit"></a>第四部分： 客户端TortoiseGit</h2><h3 id="18、客户端小乌龟：安装与中文包"><a href="#18、客户端小乌龟：安装与中文包" class="headerlink" title="18、客户端小乌龟：安装与中文包"></a>18、客户端小乌龟：安装与中文包</h3><blockquote><p>目标：掌握客户端的安装</p></blockquote><h4 id="18-1-安装客户端小乌龟"><a href="#18-1-安装客户端小乌龟" class="headerlink" title="18.1 安装客户端小乌龟"></a>18.1 安装客户端小乌龟</h4><p><img src="/2020/01/01/Git/1573316488517.png" alt="1573316488517">&nbsp;</p><p>一路“Next”使用默认选项即可。</p><p><img src="/2020/01/01/Git/1573316562626.png" alt="1573316562626">&nbsp;</p><p>默认选项下会启动配置画面：</p><p><img src="/2020/01/01/Git/1573317005900.png" alt="1573317005900"> </p><p>由于目前只有英文语言包，默认即可继续下一步。</p><p>配置git.exe，在4.2.1中已经安装过git-for-windows了所以在此找到git.exe所在的目录。</p><p><img src="/2020/01/01/Git/1573316635345.png" alt="1573316635345">&nbsp;</p><p> 配置开发者姓名及邮箱，每次提交代码时都会把此信息包含到提交的信息中。</p><p><img src="/2020/01/01/Git/1573316873671.png" alt="1573316873671"></p><p>使用默认配置，点击“完成”按钮完成配置。</p><p><img src="/2020/01/01/Git/1573316924437.png" alt="1573316924437"> </p><p>完整完毕后在系统右键菜单中会出现git的菜单项。</p><p><img src="/2020/01/01/Git/1573317073016.png" alt="1573317073016">&nbsp;</p><h4 id="18-2-安装小乌龟中文包"><a href="#18-2-安装小乌龟中文包" class="headerlink" title="18.2 安装小乌龟中文包"></a>18.2 安装小乌龟中文包</h4><p>安装中文语言包并不是必选项。可以根据个人情况来选择安装。</p><p><img src="/2020/01/01/Git/1571736676125.png" alt="1571736676125">  </p><p><img src="/2020/01/01/Git/clip_image260.jpg" alt="img"> </p><p>直接“下一步”完整完毕。</p><p>鼠标右键选择Settings</p><p><img src="/2020/01/01/Git/clip_image262.jpg" alt="img"> </p><p>语言包安装完毕后可以在TortoiseGit的设置中调整语言</p><p><img src="/2020/01/01/Git/clip_image264.jpg" alt="img"> </p><h3 id="19、客户端小乌龟：基本使用"><a href="#19、客户端小乌龟：基本使用" class="headerlink" title="19、客户端小乌龟：基本使用"></a>19、客户端小乌龟：基本使用</h3><h4 id="19-1-创建本地仓库"><a href="#19-1-创建本地仓库" class="headerlink" title="19.1 创建本地仓库"></a>19.1 创建本地仓库</h4><p>我们新建一个空的文件夹：tortoise</p><p><img src="/2020/01/01/Git/clip_image266.jpg" alt="img"> </p><p>然后进入tortoise目录，右键操作：</p><p><img src="/2020/01/01/Git/clip_image268.jpg" alt="img"> </p><p>弹出提示，不要勾选：</p><p><img src="/2020/01/01/Git/clip_image270.jpg" alt="img"> </p><p>查看目录，发现生成.git文件夹：</p><p><img src="/2020/01/01/Git/clip_image272.jpg" alt="img"> </p><p><img src="/2020/01/01/Git/1573347822882.png" alt="1573347822882">&nbsp;</p><blockquote><p>注意: 想看到对应的图标，电脑需要重启。</p></blockquote><h4 id="19-2-添加文件并提交"><a href="#19-2-添加文件并提交" class="headerlink" title="19.2 添加文件并提交"></a>19.2 添加文件并提交</h4><p>创建新的文件：</p><p><img src="/2020/01/01/Git/clip_image274.jpg" alt="img"> </p><p>编写内容：</p><p><img src="/2020/01/01/Git/clip_image276.jpg" alt="img"> </p><p>在文件夹中右键操作：</p><p><img src="/2020/01/01/Git/clip_image278.jpg" alt="img">&nbsp;</p><p>提示：这一步等同于我们的 git add readme.txt <img src="/2020/01/01/Git/clip_image280.jpg" alt="img">&nbsp;</p><p>此时直接点击提交，即可完成：git commit 操作： <img src="/2020/01/01/Git/clip_image282.jpg" alt="img"></p><p>提示：</p><p><img src="/2020/01/01/Git/clip_image284.jpg" alt="img">&nbsp;</p><h4 id="19-3-差异对比"><a href="#19-3-差异对比" class="headerlink" title="19.3 差异对比"></a>19.3 差异对比</h4><p>修改readme.txt：</p><p><img src="/2020/01/01/Git/clip_image286.jpg" alt="img">&nbsp;</p><p>右键操作：</p><p><img src="/2020/01/01/Git/clip_image288.jpg" alt="img">&nbsp;</p><p>结果：</p><p><img src="/2020/01/01/Git/clip_image290.jpg" alt="img">&nbsp;</p><h4 id="19-4-提交修改"><a href="#19-4-提交修改" class="headerlink" title="19.4 提交修改"></a>19.4 提交修改</h4><p>直接在文件上选择右键，提交即可：</p><p><img src="/2020/01/01/Git/clip_image292.jpg" alt="img">&nbsp;</p><h4 id="19-5-查看提交日志"><a href="#19-5-查看提交日志" class="headerlink" title="19.5 查看提交日志"></a>19.5 查看提交日志</h4><p>选中文件，右键菜单中，选中查看日志：</p><p><img src="/2020/01/01/Git/clip_image294.jpg" alt="img">&nbsp;</p><p>提交的日志信息：</p><p><img src="/2020/01/01/Git/clip_image296.jpg" alt="img">&nbsp;</p><h4 id="19-6-版本回退"><a href="#19-6-版本回退" class="headerlink" title="19.6 版本回退"></a>19.6 版本回退</h4><p>现在我们再次修改readme.txt，并且提交</p><p><img src="/2020/01/01/Git/clip_image298.jpg" alt="img">&nbsp;</p><p>查看日志：</p><p><img src="/2020/01/01/Git/clip_image300.jpg" alt="img">&nbsp;</p><p>假如我们要回到上一个版本，也就是第2次提交。</p><p>我们选中第2次提交，然后右键，选中：重置“master”到这个版本</p><p><img src="/2020/01/01/Git/clip_image302.jpg" alt="img">&nbsp;</p><p>弹出菜单，这里选中Hard模式，然后确定：</p><p><img src="/2020/01/01/Git/clip_image304.jpg" alt="img">&nbsp;</p><p>再次查看日志，只剩下第1和第2次提交了。并且HEAD已经设置到了第2次提交位置</p><p><img src="/2020/01/01/Git/clip_image306.jpg" alt="img">&nbsp;</p><p>文件也回滚了：</p><p><img src="/2020/01/01/Git/clip_image308.jpg" alt="img">&nbsp;</p><p>如果我现在后悔了，想再次回到第3次提交怎么办？现在连日志都没有了！</p><p>此时，在空白处点击右键，选中 显示引用记录：</p><p><img src="/2020/01/01/Git/clip_image310.jpg" alt="img">&nbsp;</p><p>弹出所有操作的日志信息：</p><p><img src="/2020/01/01/Git/clip_image312.jpg" alt="img">&nbsp;</p><p>现在，我们找到第3次提交，右键，选中：重置“master”到这个版本</p><p><img src="/2020/01/01/Git/clip_image314.jpg" alt="img">&nbsp;</p><p>结果，第3次提交又回来了！</p><p><img src="/2020/01/01/Git/clip_image316.jpg" alt="img">&nbsp;</p><p>文件内容回来了：</p><p><img src="/2020/01/01/Git/clip_image318.jpg" alt="img">&nbsp;</p><h4 id="19-7-撤销修改"><a href="#19-7-撤销修改" class="headerlink" title="19.7 撤销修改"></a>19.7 撤销修改</h4><p>我们现在修改文件：</p><p><img src="/2020/01/01/Git/clip_image320.jpg" alt="img">&nbsp;</p><p>现在后悔了，想要还原到修改以前。</p><p>我们可以选中文件，右键。然后选中菜单：还原。</p><p><img src="/2020/01/01/Git/clip_image322.jpg" alt="img">&nbsp;</p><p>点击确定：</p><p><img src="/2020/01/01/Git/clip_image324.jpg" alt="img">&nbsp;</p><p>还原成功：</p><p><img src="/2020/01/01/Git/clip_image326.jpg" alt="img">&nbsp;</p><p>查看文件：</p><p><img src="/2020/01/01/Git/clip_image328.jpg" alt="img">&nbsp;</p><h2 id="第五部分：Idea操作Git【重点】"><a href="#第五部分：Idea操作Git【重点】" class="headerlink" title="第五部分：Idea操作Git【重点】"></a>第五部分：Idea操作Git【重点】</h2><h3 id="20、Idea：配置Git"><a href="#20、Idea：配置Git" class="headerlink" title="20、Idea：配置Git"></a>20、Idea：配置Git</h3><p>在Idea中配置Git,打开File菜单:</p><p><strong>在File –&gt; Settings -&gt; Version Control –&gt; Git –&gt;Path to Git executable选择你的git安装后的git.exe文件</strong></p><ul><li><strong>方式一</strong></li></ul><p><img src="/2020/01/01/Git/1571913145490.png" alt="1571913145490"> </p><ul><li><strong>方式二</strong></li></ul><p><img src="/2020/01/01/Git/1571913325967.png" alt="1571913325967"> </p><p>配置本地安装的Git:</p><p><img src="/2020/01/01/Git/1573349918013.png" alt="1573349918013"> </p><h3 id="21、Idea：创建本地仓库"><a href="#21、Idea：创建本地仓库" class="headerlink" title="21、Idea：创建本地仓库"></a>21、Idea：创建本地仓库</h3><ul><li><p>新建一个maven工程</p><p><img src="/2020/01/01/Git/clip_image436.jpg" alt="img">&nbsp;</p><p>编写简单的代码：</p><p><img src="/2020/01/01/Git/clip_image438.jpg" alt="img">&nbsp;</p></li><li><p>创建Git本地仓库</p><p>VCS菜单: <strong>VCS  –&gt;  Import into Version Control –&gt; Create Git Repository…</strong></p><p><img src="/2020/01/01/Git/clip_image440.jpg" alt="img"></p><p>在弹框中选中项目所在的位置，<strong>点击</strong>OK，此时项目文件全部变成<strong>棕色</strong></p><p><img src="/2020/01/01/Git/clip_image442.jpg" alt="img">&nbsp;</p><p>项目Git版本已经创建成功。</p><p><img src="/2020/01/01/Git/clip_image444.jpg" alt="img">&nbsp;</p></li></ul><h3 id="22、Idea：忽略文件"><a href="#22、Idea：忽略文件" class="headerlink" title="22、Idea：忽略文件"></a>22、Idea：忽略文件</h3><p>这里可以手动修改.gitignore文件，也可以通过插件过滤。我们手动修改：ssmcodegen j2eecfggen</p><p><img src="/2020/01/01/Git/1574323939391.png" alt="1574323939391"> </p><p><img src="/2020/01/01/Git/1574324280517.png" alt="1574324280517">   </p><p>.gitignore</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 官方忽略</span></span><br><span class="line"><span class="comment"># Compiled class file</span></span><br><span class="line"><span class="attr">*.class</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Log file</span></span><br><span class="line"><span class="attr">*.log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># BlueJ files</span></span><br><span class="line"><span class="attr">*.ctxt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Mobile Tools for Java (J2ME)</span></span><br><span class="line"><span class="attr">.mtj.tmp/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Package Files #</span></span><br><span class="line"><span class="attr">*.jar</span></span><br><span class="line"><span class="attr">*.war</span></span><br><span class="line"><span class="attr">*.nar</span></span><br><span class="line"><span class="attr">*.ear</span></span><br><span class="line"><span class="attr">*.zip</span></span><br><span class="line"><span class="attr">*.tar.gz</span></span><br><span class="line"><span class="attr">*.rar</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xml</span></span><br><span class="line"><span class="attr">hs_err_pid*</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增</span></span><br><span class="line"><span class="attr">.classpath</span></span><br><span class="line"><span class="attr">.project</span></span><br><span class="line"><span class="attr">.settings</span></span><br><span class="line"><span class="attr">target</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># idea</span></span><br><span class="line"><span class="attr">*.iml</span></span><br><span class="line"><span class="attr">.idea</span></span><br></pre></td></tr></table></figure><h3 id="23、Idea：提交代码"><a href="#23、Idea：提交代码" class="headerlink" title="23、Idea：提交代码"></a>23、Idea：提交代码</h3><h4 id="23-1-添加到暂存区"><a href="#23-1-添加到暂存区" class="headerlink" title="23.1 添加到暂存区"></a>23.1 添加到暂存区</h4><p>项目右键选择Git –&gt; add</p><p>此时项目文件变成绿色，此时文件只是处于暂存区，并没有真正进入到版本库中。</p><p><img src="/2020/01/01/Git/clip_image448.jpg" alt="img">&nbsp;</p><p>此时项目文件全部变成<strong>绿色</strong>。</p><p><img src="/2020/01/01/Git/clip_image450.jpg" alt="img">&nbsp;</p><h4 id="23-1-提交至本地仓库"><a href="#23-1-提交至本地仓库" class="headerlink" title="23.1 提交至本地仓库"></a>23.1 提交至本地仓库</h4><p>项目右键Git –&gt; Commit Directory</p><p>在弹窗中输入Commit Message，点击commit，此时项目文件从暂存区真正进入版本库中，项目文件变成<strong>黑色</strong>。</p><p><img src="/2020/01/01/Git/clip_image452.jpg" alt="img">&nbsp;</p><p>编辑本次提交备注信息，然后点击commit按钮。</p><p><img src="/2020/01/01/Git/clip_image454.jpg" alt="img">&nbsp;</p><p>此时项目文件全部变成<strong>黑色</strong>：</p><p><img src="/2020/01/01/Git/clip_image456.jpg" alt="img"> </p><h3 id="24、Idea：提交远程仓库"><a href="#24、Idea：提交远程仓库" class="headerlink" title="24、Idea：提交远程仓库"></a>24、Idea：提交远程仓库</h3><h4 id="24-1-新建一个远程仓库"><a href="#24-1-新建一个远程仓库" class="headerlink" title="24.1 新建一个远程仓库"></a>24.1 新建一个远程仓库</h4><ul><li><p>在远程仓库创建新项目</p><p><img src="/2020/01/01/Git/clip_image458.jpg" alt="img"></p></li><li><p>记录地址</p><p><img src="/2020/01/01/Git/clip_image460.jpg" alt="img"></p></li></ul><h4 id="24-2-推送到远程仓库"><a href="#24-2-推送到远程仓库" class="headerlink" title="24.2 推送到远程仓库"></a>24.2 推送到远程仓库</h4><ul><li><p>右键菜单 —&gt; <strong>Git –&gt; Repository –&gt; Push</strong>，然后填写远程仓库地址。</p><p><img src="/2020/01/01/Git/clip_image462.jpg" alt="img"></p></li><li><p>复制远程仓库的地址，并填写</p><p><img src="/2020/01/01/Git/clip_image464.jpg" alt="img"></p></li><li><p>选择远程分支的名称，点击Push：</p><p><img src="/2020/01/01/Git/clip_image466.jpg" alt="img">&nbsp;</p></li><li><p>推送成功, 在Idea右下角弹出提示框</p><p><img src="/2020/01/01/Git/clip_image468.jpg" alt="img">&nbsp;</p></li><li><p>查看远程仓库，推送成功。</p><p><img src="/2020/01/01/Git/clip_image470.jpg" alt="img"></p></li></ul><h4 id="24-3-拉取远程仓库"><a href="#24-3-拉取远程仓库" class="headerlink" title="24.3 拉取远程仓库"></a>24.3 拉取远程仓库</h4><ul><li><p>在远程仓库随意修改代码</p><p><img src="/2020/01/01/Git/clip_image472.jpg" alt="img"></p></li><li><p>在项目中，拉取代码</p><p><img src="/2020/01/01/Git/clip_image474.jpg" alt="img"></p></li><li><p>点击Pull</p><p><img src="/2020/01/01/Git/clip_image476.jpg" alt="img">&nbsp;</p></li><li><p>代码成功同步</p><p><img src="/2020/01/01/Git/clip_image478.jpg" alt="img">&nbsp;</p></li></ul><h3 id="25、Idea：克隆项目"><a href="#25、Idea：克隆项目" class="headerlink" title="25、Idea：克隆项目"></a>25、Idea：克隆项目</h3><h4 id="25-1-Idea项目断开Git关联"><a href="#25-1-Idea项目断开Git关联" class="headerlink" title="25.1 Idea项目断开Git关联"></a>25.1 Idea项目断开Git关联</h4><ul><li><p>打开Settings…</p><p><img src="/2020/01/01/Git/clip_image480.jpg" alt="img">&nbsp;</p></li><li><p>断开idea与Git版本仓库的关联：</p><p><img src="/2020/01/01/Git/clip_image482.jpg" alt="img"></p><p>Idea和项目Git版本控制断开关联。</p></li></ul><h4 id="25-2-克隆远程仓库并导入Idea"><a href="#25-2-克隆远程仓库并导入Idea" class="headerlink" title="25.2 克隆远程仓库并导入Idea"></a>25.2 克隆远程仓库并导入Idea</h4><ul><li><p>打开Idea: 点击 Check out form Version Control，选中Git</p><p><img src="/2020/01/01/Git/clip_image484.jpg" alt="img">&nbsp;</p></li><li><p>填入远程仓库SSH地址，输入你的远程仓库地址，点击Test，测试一下地址是否正确。点击Clone</p><p><img src="/2020/01/01/Git/1573354374077.png" alt="1573354374077"></p></li><li><p>点击YES，Clone出远程仓储的工程，并且导入到idea中。</p><p><img src="/2020/01/01/Git/clip_image488.jpg" alt="img">&nbsp;</p></li><li><p>选择maven导入方式，直到操作完成。</p><p><img src="/2020/01/01/Git/clip_image490.jpg" alt="img">&nbsp;</p></li><li><p>右键Git，可以与远程仓库进行push和pull代码操作了。</p><p><img src="/2020/01/01/Git/clip_image492.jpg" alt="img">&nbsp;</p></li></ul><h3 id="26、Idea：解决冲突"><a href="#26、Idea：解决冲突" class="headerlink" title="26、Idea：解决冲突"></a>26、Idea：解决冲突</h3><h4 id="26-1-制造冲突"><a href="#26-1-制造冲突" class="headerlink" title="26.1 制造冲突"></a>26.1 制造冲突</h4><ul><li><p>我们创建新的分支dev，并且在dev修改提交代码</p><p><img src="/2020/01/01/Git/1573355830861.png" alt="1573355830861"></p><p><img src="/2020/01/01/Git/1573355020745.png" alt="1573355020745">&nbsp;</p><p><img src="/2020/01/01/Git/1573355046092.png" alt="1573355046092">&nbsp;</p><p><img src="/2020/01/01/Git/1573356011912.png" alt="1573356011912">&nbsp;</p><blockquote><p>说明: 提交代码到本地仓库。</p></blockquote></li><li><p>然后在master修改提交代码</p><ul><li>切换到master分支</li></ul><p><img src="/2020/01/01/Git/1573356257610.png" alt="1573356257610">&nbsp;</p><ul><li><p>修改GitDemo.java</p><p><img src="/2020/01/01/Git/1573356369295.png" alt="1573356369295"></p></li><li><p>提交代码到本地仓库</p><p><img src="/2020/01/01/Git/1573356570175.png" alt="1573356570175"></p></li></ul></li><li><p>接下来尝试合并dev分支</p><p><img src="/2020/01/01/Git/clip_image494.jpg" alt="img">&nbsp;</p></li><li><p>选择要合并的分支</p><p><img src="/2020/01/01/Git/clip_image496.jpg" alt="img">&nbsp;</p><p>发现合并失败,此时文件有<strong>红色标记</strong></p><p><img src="/2020/01/01/Git/clip_image498.jpg" alt="img">&nbsp;</p></li></ul><h4 id="26-2-解决冲突"><a href="#26-2-解决冲突" class="headerlink" title="26.2 解决冲突"></a>26.2 解决冲突</h4><ul><li><p>使用右键，菜单工具：<strong>Resolve Confilcts…</strong></p><p><img src="/2020/01/01/Git/clip_image500.jpg" alt="img">&nbsp;</p></li><li><p>点击Merge合并策略:</p><ul><li>Accept Yours：保留你自己的代码</li><li>Accept Theirs：保留别人的代码</li><li>merge：人工合并 (人工把需要的代码复制粘贴到结果集result里面比较保险)</li></ul><p><img src="/2020/01/01/Git/clip_image502.jpg" alt="img">&nbsp;</p></li><li><p>弹出一个对比页面</p><p>在Result中，手动合并完成后，点击Apply按钮，完成冲突代码合并。</p><p><img src="/2020/01/01/Git/clip_image504.jpg" alt="img"></p></li><li><p>此时文件的红色标记没了</p><p><img src="/2020/01/01/Git/clip_image506.jpg" alt="img">&nbsp;</p></li></ul><p>&nbsp;  但是有未提交的<strong>蓝色标记</strong>。然后提交，文件变为<strong>黑色</strong>。冲突被解决！</p><p>   <img src="/2020/01/01/Git/clip_image508.jpg" alt="img">   </p><p>   <img src="/2020/01/01/Git/clip_image514.jpg" alt="img">    </p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
